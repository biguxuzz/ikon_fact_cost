# Задание: Оптимизация алгоритма разузлования

## Обзор оптимизаций

| # | Оптимизация | Сложность | Ожидаемый эффект | Условие применения |
|---|-------------|-----------|------------------|---------------------|
| 1 | Пакетные запросы | Средняя | Сокращение запросов с N до 1 на уровень | Запросы > 70% времени |
| 2 | Соответствие для ПройденныйПуть | Низкая | O(1) поиск вместо O(n) | ПройденныйПуть > 1000 строк |
| 3 | Кэширование партий | Средняя | Исключение повторных запросов | Повторяющиеся партии > 20% |

---

## Оптимизация 1: Пакетные запросы (ГЛАВНАЯ)

### Суть проблемы

Текущий код выполняет **отдельный запрос для каждого узла**:

```bsl
// Строки 810-848 в Module.bsl
Для Каждого Узел Из УзлыДляОбработки Цикл
    СебестоимостьУзла = СебестоимостьУзла(...);  // ← N ЗАПРОСОВ!
КонецЦикла;
```

При 100 узлах на уровне = 100 запросов к БД. При 5 уровнях = 500+ запросов.

### Решение

Использовать уже готовую функцию `СебестоимостьУзловПакетом` (строки 1133-1257), которая выполняет **ОДИН запрос для всех узлов уровня**.

### Изменения в коде

#### Шаг 1: Модифицировать функцию `РазузловатьУзлыПакетом`

**Найти** (строки 808-848):
```bsl
УзлыСледующегоУровня = Новый Массив;

// Обработка каждого узла с отдельным запросом
// (текущая версия - без объединения запросов, но с обработкой по уровням)
Для Каждого Узел Из УзлыДляОбработки Цикл
    
    // Определяем, нужно ли выводить дополнительные расходы
    УровеньУзла = Узел.ОписаниеПродукции.Уровень + 1;
    
    // Проверка максимальной глубины рекурсии
    Если УровеньУзла > ПараметрыДерева.МаксимальнаяГлубинаРекурсии Тогда
        // ... логирование ...
        Продолжить;
    КонецЕсли;
    
    ВыводитьДопРасходы = Узел.ПараметрыУзла.Отборы.РазворачиватьДопРасходы 
        И НЕ (Узел.ОписаниеПродукции.Уровень = 0);
    
    // Получаем данные для текущего узла отдельным запросом
    СебестоимостьУзла = СебестоимостьУзла(ПараметрыДерева, Узел.ПараметрыУзла, ВыводитьДопРасходы);
        
    // СтандартныеПодсистемы.ЗамерПроизводительности
    ПараметрыДерева.КоличествоСтрок = ПараметрыДерева.КоличествоСтрок + СебестоимостьУзла.Количество();
    // Конец СтандартныеПодсистемы.ЗамерПроизводительности
    
    // Обрабатываем каждую партию в результатах
    ОбработатьРезультатыУзла(ПараметрыДерева, Узел, СебестоимостьУзла, ПройденныйПуть, УзлыСледующегоУровня);
КонецЦикла;
```

**Заменить на:**
```bsl
УзлыСледующегоУровня = Новый Массив;

// === ОПТИМИЗАЦИЯ: Пакетный запрос для всех узлов уровня ===

// 1. Фильтруем узлы по глубине и собираем параметры
УзлыДляЗапроса = Новый Массив;
СоответствиеУзлов = Новый Соответствие;  // КлючУзла -> Узел

Для Каждого Узел Из УзлыДляОбработки Цикл
    УровеньУзла = Узел.ОписаниеПродукции.Уровень + 1;
    
    // Проверка максимальной глубины
    Если УровеньУзла > ПараметрыДерева.МаксимальнаяГлубинаРекурсии Тогда
        ПартияПродукции = Узел.ОписаниеПродукции.ПартияПродукции;
        АналитикаУчетаПартийПродукции = Узел.ОписаниеПродукции.АналитикаУчетаПартийПродукции;
        
        ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
            "Достигнута максимальная глубина разузлования (%1 уровней). Партия: %2, Аналитика партий: %3",
            Строка(УровеньУзла),
            Строка(ПартияПродукции),
            Строка(АналитикаУчетаПартийПродукции));
        ЗаписьЖурналаРегистрации(
            "СтруктураСебестоимости.МаксимальнаяГлубинаРекурсии",
            УровеньЖурналаРегистрации.Предупреждение,
            ,
            ,
            ТекстСообщения);
        Продолжить;
    КонецЕсли;
    
    УзлыДляЗапроса.Добавить(Узел.ПараметрыУзла);
    КлючУзла = СоздатьКлючУзла(Узел.ПараметрыУзла);
    СоответствиеУзлов.Вставить(КлючУзла, Узел);
КонецЦикла;

// 2. Выполняем ОДИН пакетный запрос
Если УзлыДляЗапроса.Количество() > 0 Тогда
    
    // Определяем ВыводитьДопРасходы (берём из первого узла, должно быть одинаково для уровня)
    ПервыйУзел = УзлыДляОбработки[0];
    ВыводитьДопРасходы = ПервыйУзел.ПараметрыУзла.Отборы.РазворачиватьДопРасходы 
        И НЕ (ПервыйУзел.ОписаниеПродукции.Уровень = 0);
    
    // ОДИН запрос для ВСЕХ узлов!
    РезультатыПоУзлам = СебестоимостьУзловПакетом(УзлыДляЗапроса, ВыводитьДопРасходы, Неопределено);
    
    // 3. Обрабатываем результаты для каждого узла
    Для Каждого Узел Из УзлыДляОбработки Цикл
        УровеньУзла = Узел.ОписаниеПродукции.Уровень + 1;
        Если УровеньУзла > ПараметрыДерева.МаксимальнаяГлубинаРекурсии Тогда
            Продолжить;  // Уже обработано выше
        КонецЕсли;
        
        КлючУзла = СоздатьКлючУзла(Узел.ПараметрыУзла);
        СебестоимостьУзла = РезультатыПоУзлам.Получить(КлючУзла);
        
        Если СебестоимостьУзла = Неопределено Тогда
            СебестоимостьУзла = Новый ТаблицаЗначений;  // Пустая таблица если нет данных
        КонецЕсли;
        
        // СтандартныеПодсистемы.ЗамерПроизводительности
        ПараметрыДерева.КоличествоСтрок = ПараметрыДерева.КоличествоСтрок + СебестоимостьУзла.Количество();
        // Конец СтандартныеПодсистемы.ЗамерПроизводительности
        
        ОбработатьРезультатыУзла(ПараметрыДерева, Узел, СебестоимостьУзла, ПройденныйПуть, УзлыСледующегоУровня);
    КонецЦикла;
КонецЕсли;
```

#### Шаг 2: Исправить функцию `СебестоимостьУзловПакетом`

Функция уже существует (строки 1133-1257), но нужно исправить проблему с `Числитель` и `КоличествоПродукции`, которые индивидуальны для каждого узла.

**Найти** (около строки 1224):
```bsl
// Выполняем ОДИН запрос для ВСЕХ узлов уровня
Запрос = ЗапросВыпущеннаяПродукция(ПараметрыУзлаОбъединенные, Истина);
Запрос.Текст = Запрос.Текст + ТекстЗапросаЗатратыНаПродукцию(ВыводитьДопРасходы);

ВсеДанные = Запрос.Выполнить().Выгрузить();
```

**Проблема**: Параметры `Числитель` и `КоличествоПродукции` индивидуальны для каждого узла и влияют на расчёт сумм. При объединении запросов нужно либо:
- **Вариант А**: Выполнять запрос без пропорционального расчёта, а пересчитывать суммы при распределении
- **Вариант Б**: Добавить в запрос группировку по ПартияПродукции и возвращать данные без пересчёта

**Рекомендация**: Начать с Варианта А — он проще и безопаснее.

---

## Оптимизация 2: Соответствие для ПройденныйПуть

### Суть проблемы

Текущий код использует `ТаблицаЗначений.НайтиСтроки()` с линейным поиском O(n):

```bsl
ПройденныйПуть = Новый ТаблицаЗначений;
// ...
МассивСтрок = ПройденныйПуть.НайтиСтроки(ПараметрыОтбора);  // O(n)!
```

При 1000+ партий в пути каждая проверка занимает значительное время.

### Решение

Использовать `Соответствие` для O(1) поиска.

### Изменения в коде

#### Шаг 1: Изменить инициализацию

**Найти** (строки 113-119):
```bsl
ПройденныйПуть = Новый ТаблицаЗначений;
ПройденныйПуть.Колонки.Добавить("Партия");
ПройденныйПуть.Колонки.Добавить("АналитикаУчетаПартий");
ПройденныйПуть.Индексы.Добавить("Партия, АналитикаУчетаПартий");
ПараметрыДерева.Вставить("ПройденныйПуть", ПройденныйПуть);
```

**Заменить на:**
```bsl
// ОПТИМИЗАЦИЯ: Соответствие вместо ТаблицаЗначений для O(1) поиска
ПройденныйПуть = Новый Соответствие;
ПараметрыДерева.Вставить("ПройденныйПуть", ПройденныйПуть);
```

#### Шаг 2: Изменить проверку на цикл

**Найти** (все места с `НайтиСтроки`):
```bsl
ПараметрыОтбора = Новый Структура("Партия, АналитикаУчетаПартий",
    ТекПартия.ПартияЗатрата,
    ТекПартия.АналитикаУчетаПартийЗатрата);
МассивСтрок = ПройденныйПуть.НайтиСтроки(ПараметрыОтбора);
```

**Заменить на:**
```bsl
// ОПТИМИЗАЦИЯ: O(1) поиск через Соответствие
КлючПути = СоздатьКлючПути(ТекПартия.ПартияЗатрата, ТекПартия.АналитикаУчетаПартийЗатрата);
ЕстьВПути = ПройденныйПуть.Получить(КлючПути) <> Неопределено;
```

#### Шаг 3: Изменить добавление в путь

**Найти**:
```bsl
НовыйПуть = ПройденныйПуть.Добавить();
НовыйПуть.Партия = ТекПартия.ПартияЗатрата;
НовыйПуть.АналитикаУчетаПартий = ТекПартия.АналитикаУчетаПартийЗатрата;
```

**Заменить на:**
```bsl
// ОПТИМИЗАЦИЯ: Добавление через Соответствие
КлючПути = СоздатьКлючПути(ТекПартия.ПартияЗатрата, ТекПартия.АналитикаУчетаПартийЗатрата);
ПройденныйПуть.Вставить(КлючПути, Истина);
```

#### Шаг 4: Добавить вспомогательную функцию

```bsl
// Создаёт уникальный ключ для пути на основе партии и аналитики
Функция СоздатьКлючПути(Партия, АналитикаУчетаПартий)
    Возврат Строка(Партия.УникальныйИдентификатор()) 
        + "|" + Строка(АналитикаУчетаПартий.УникальныйИдентификатор());
КонецФункции
```

#### Шаг 5: Обновить условия проверки цикла

**Было:**
```bsl
Если МассивСтрок.Количество() > 0 Тогда
    // Цикл обнаружен
КонецЕсли;
```

**Стало:**
```bsl
Если ЕстьВПути Тогда
    // Цикл обнаружен
КонецЕсли;
```

---

## Оптимизация 3: Кэширование партий

### Суть проблемы

Если одна партия полуфабриката используется в нескольких продуктах, данные о её себестоимости запрашиваются многократно.

### Решение

Глобальный кэш результатов на уровне сессии построения дерева.

### Изменения в коде

#### Шаг 1: Инициализация кэша

В `ikon_cost_ПостроитьДеревоСебестоимости` добавить:
```bsl
ПараметрыДерева.Вставить("КэшСебестоимости", Новый Соответствие);
```

#### Шаг 2: Проверка кэша перед запросом

В `СебестоимостьУзла` (или в новой пакетной функции):
```bsl
// Проверяем кэш
КлючКэша = СоздатьКлючКэша(ПараметрыУзла);
Если ПараметрыДерева.Свойство("КэшСебестоимости") Тогда
    КэшированныйРезультат = ПараметрыДерева.КэшСебестоимости.Получить(КлючКэша);
    Если КэшированныйРезультат <> Неопределено Тогда
        Возврат КэшированныйРезультат.Скопировать();  // Возвращаем копию!
    КонецЕсли;
КонецЕсли;

// ... выполняем запрос ...

// Сохраняем в кэш
Если ПараметрыДерева.Свойство("КэшСебестоимости") Тогда
    ПараметрыДерева.КэшСебестоимости.Вставить(КлючКэша, Результат.Скопировать());
КонецЕсли;
```

---

## Порядок внедрения

### Рекомендуемый порядок:

1. **Оптимизация 2** (Соответствие) — низкий риск, быстрое внедрение
2. **Оптимизация 1** (Пакетные запросы) — максимальный эффект, требует тестирования
3. **Оптимизация 3** (Кэширование) — дополнительный эффект при наличии повторов

### Чек-лист перед внедрением каждой оптимизации:

- [ ] Сохранить результаты старого алгоритма (ИспользоватьПакетнуюОбработку = Ложь)
- [ ] Внести изменения
- [ ] Загрузить расширение
- [ ] Проверить отсутствие ошибок в журнале регистрации
- [ ] Сравнить результаты с эталоном
- [ ] Выполнить замеры производительности
- [ ] Зафиксировать изменения в git

---

## Критерии успеха

| Метрика | Цель |
|---------|------|
| Результат отчёта | Идентичен старому алгоритму |
| Время выполнения | Сокращение на 50%+ |
| Количество запросов | Сокращение в 10+ раз |
| Ошибки в журнале | Отсутствуют |
