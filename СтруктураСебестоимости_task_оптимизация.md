# Задание: Оптимизация алгоритма разузлования

## Текущий статус

### Результаты тестирования (v0.1.1.74 ГИБРИД) ✅

| Показатель | Старый алгоритм | Гибридный алгоритм | Статус |
|------------|-----------------|---------------------|--------|
| **Итоговая стоимость** | 2 758 680,13 ₽ | 2 758 680,13 ₽ | ✅ **СОВПАДАЕТ** |
| **Время выполнения** | 29 сек | 30 сек | ⚠️ Аналогично |
| **Время запросов** | 29 сек | 28 сек | ✅ -3,4% |
| **Количество запросов** | 47 | 46 | ⚠️ -1 запрос |

**Примечание**: Сравнение выполняется через разные MCP-инструменты:
- `prod_cost` - использует СТАРЫЙ алгоритм (валюта регл. учёта)
- `prod_cost_ext` - использует ГИБРИДНЫЙ алгоритм (валюта упр. учёта с НДС)

### Реализация гибридной обработки (v0.1.1.74) ✅

Реализован **гибридный подход** для решения проблемы декартова произведения:

| Уровень | Всего узлов | Пакетом | Индивидуально | Причина |
|---------|-------------|---------|---------------|---------|
| 1-3 | 1-5 | 100% | 0% | Уникальные пары |
| 4 | 5 | 60% | 40% | Появляются дубликаты |
| 5-7 | 12-16 | 0% | 100% | Все пары дублируются |

**Вывод**: На данных тестовой базы большинство узлов на глубоких уровнях имеют 
дублирующиеся пары (ПартияПродукции, АналитикаУчетаПартийПродукции), что делает 
пакетную обработку неэффективной. Экономия всего 1 запрос (46 vs 47).

### Исследование пакетной обработки (v0.1.0.51-74) ⚠️ ЧАСТИЧНО РЕШЕНО

Попытка реализовать **Вариант B: Временные таблицы с JOIN** выявила проблемы:

| Версия | Запросов | Время | Результат | Статус |
|--------|----------|-------|-----------|--------|
| v0.1.0.51 (IN массивы) | 7 | 9 сек | 29 333 283,40 ₽ | ❌ x10,6 |
| v0.1.0.52 (IN массивы) | 7 | - | 49 811 369,10 ₽ | ❌ x18,1 |
| v0.1.0.54 (кортеж В) | 7 | - | Ошибка типов | ❌ |
| v0.1.0.55 (JOIN ВТ) | 7 | 11 сек | 50 963 078,55 ₽ | ❌ x18,5 |
| v0.1.0.56 (индивид.) | 47 | 33 сек | 2 758 680,13 ₽ | ✅ Точно |

### Анализ причин неудачи пакетной обработки

#### Причина 1: Декартово произведение (v0.1.0.51-52)

Запрос с `IN(...)`:
```sql
WHERE Партия IN (&ПартииПродукции) AND Аналитика IN (&АналитикиУчетаПартийПродукции)
```
При `ПартииПродукции = [P1, P2]` и `Аналитики = [A1, A2]` возвращает **все 4 комбинации** вместо 2 нужных пар.

#### Причина 2: Потеря индивидуальных коэффициентов (v0.1.0.55) ⚠️ КРИТИЧЕСКАЯ

Даже при использовании синтаксиса 1С:
```sql
(Партия, Аналитика) В (ВЫБРАТЬ ПартияПродукции, АналитикаУчетаПартийПродукции ИЗ ВТПарыУзлов)
```

**Проблема**: Каждый узел имеет индивидуальные параметры `Числитель/Знаменатель`, которые используются для расчёта **доли затрат**:
```sql
* ВЫРАЗИТЬ(НЗППоПродукции.Числитель / НЗППоПродукции.Знаменатель КАК ЧИСЛО(31,10))
```

Эти коэффициенты передаются в запрос как **единые параметры** `&Числитель` и `&Знаменатель`. 
При пакетной обработке невозможно передать **разные коэффициенты для разных пар** без 
кардинальной модификации структуры запроса.

### Вывод: Полная пакетная обработка НЕВОЗМОЖНА ❌ (обновлено v0.1.1.74)

**Реализован гибридный подход**, но он не даёт существенной экономии:

| Проблема | Причина | Влияние |
|----------|---------|---------|
| Дублирующиеся пары | Одна партия появляется в разных ветках дерева | 75% узлов обрабатываются индивидуально |
| Числитель/Знаменатель | Индивидуальные коэффициенты для каждого узла | Невозможно использовать общий запрос |
| Декартово произведение | JOIN множит строки при дубликатах | Неправильные суммы |

**Текущая реализация (v0.1.1.74 ГИБРИД):**
- ✅ **100% корректность** результатов
- ✅ **Гибридный алгоритм** - уникальные пары пакетом, дубликаты индивидуально
- ⚠️ **46 запросов** вместо 47 (-2%)
- ⚠️ **Время аналогичное** старому алгоритму

**Компоненты системы:**

| MCP-инструмент | Отчёт | Алгоритм | Параметр |
|----------------|-------|----------|----------|
| `prod_cost` | Типовой | СТАРЫЙ (рекурсивный) | `ИспользоватьПакетнуюОбработку = Ложь` |
| `prod_cost_ext` | Расширение | ГИБРИДНЫЙ | `ИспользоватьПакетнуюОбработку = Истина` |

### Результаты тестирования (v0.1.0.48) ✅

| Показатель | Старый алгоритм | Новый алгоритм | Статус |
|------------|-----------------|----------------|--------|
| **Итоговая стоимость** | 2 758 680,13 ₽ | 2 758 680,13 ₽ | ✅ **СОВПАДАЕТ** |
| **Время выполнения** | 40 сек | 53 сек | ⚠️ +32,5% |
| **Время запросов** | 39 сек | 47 сек | ⚠️ +20,5% |
| **Количество запросов** | 47 | 47 | ⚠️ Без изменений |

### Результаты тестирования (v0.1.0.35) ❌

| Показатель | Старый алгоритм | Новый алгоритм | Статус |
|------------|-----------------|----------------|--------|
| **Итоговая стоимость** | 2 758 680,13 ₽ | 2 743 789,88 ₽ | ❌ **РАСХОЖДЕНИЕ** |
| **Время выполнения** | 40 сек | 33 сек | ✅ -17,5% |
| **Время запросов** | 39 сек | 29 сек | ✅ -25,6% |
| **Количество запросов** | 47 | 47 | ⚠️ Без изменений |

### Выявленная проблема (v0.1.0.35)

**Расхождение: -14 890,25 ₽ (-0,54%)**

Проблемная позиция: **"(ОЕМ) Каучук натуральный STR 20"**

| Показатель | Старый | Новый | Проблема |
|------------|--------|-------|----------|
| Материальные | 40 999,63 ₽ | 40 999,63 ₽ | ✅ Совпадает |
| **Доп. расходы** | **14 890,25 ₽** | **0 ₽** | ❌ **ПОТЕРЯНЫ** |
| Стоимость | 55 889,89 ₽ | 40 999,64 ₽ | ❌ Расхождение |

### Решение проблемы (v0.1.0.48) ✅

**Проблема решена!** Расхождение устранено: **0 ₽**

| Показатель | Старый | Новый | Статус |
|------------|--------|-------|--------|
| Материальные | 40 999,63 ₽ | 40 999,63 ₽ | ✅ Совпадает |
| **Доп. расходы** | **14 890,25 ₽** | **14 890,25 ₽** | ✅ **ИСПРАВЛЕНО** |
| Стоимость | 55 889,89 ₽ | 55 889,89 ₽ | ✅ Совпадает |

---

## Анализ причины расхождения

### Механизм вывода дополнительных расходов

Дополнительные расходы добавляются в результат через отдельный блок запроса `ТекстДопРасходыОбъединение`, который выполняется **только** если параметр `ВыводитьДопРасходы = Истина`.

### Условие вывода дополнительных расходов

**Старый алгоритм** (строка 3174):
```
ВыводитьДопРасходы = РазворачиватьДопРасходы И НЕ (УровеньУзла = 1)
```
Где `УровеньУзла = ОписаниеПродукции.Уровень + 1`

**Новый алгоритм** (строки 3898-3899, 3941-3942):
```
ВыводитьДопРасходы = РазворачиватьДопРасходы И НЕ (ОписаниеПродукции.Уровень = 0)
```

### Математическая эквивалентность условий

| Старый | Новый | Эквивалентны? |
|--------|-------|---------------|
| `НЕ (УровеньУзла = 1)` | `НЕ (ОписаниеПродукции.Уровень = 0)` | ✅ Да |

Поскольку `УровеньУзла = ОписаниеПродукции.Уровень + 1`, условия **математически эквивалентны**.

### Гипотеза: Проблема в передаче уровня

Условия эквивалентны, **НО** значение `ОписаниеПродукции.Уровень` может отличаться в новом алгоритме из-за ошибки в передаче уровня между уровнями дерева.

#### Как формируется уровень для дочерних узлов

1. При создании узла для следующего уровня (строка 4210):
   - `НовоеОписаниеПродукции.Уровень = УровеньУзла`
   - Где `УровеньУзла = ОписаниеПродукции.Уровень + 1` (строка 3997)

2. Это означает, что для узла на глубине N:
   - `ОписаниеПродукции.Уровень = N - 1`

#### Возможные точки ошибки

| Место | Что может быть неверно |
|-------|------------------------|
| Строка 3544 | При добавлении узла в `УзлыДляПакетнойОбработки` передаётся исходный `ОписаниеПродукции`, а не модифицированный |
| Строка 4210 | При создании `НовоеОписаниеПродукции` уровень устанавливается неверно |
| Строки 3898-3899 | Условие проверяет не тот уровень |

---

## Варианты решения

### Вариант 1: Унификация условия с использованием УровеньУзла

**Суть**: В новом алгоритме уже вычисляется `УровеньУзла` (строка 3877), но в условии используется сырое значение `ОписаниеПродукции.Уровень`. Нужно использовать `УровеньУзла` для единообразия со старым алгоритмом.

**Изменение**: В строках 3898-3899 и 3941-3942 заменить условие:
- **Было**: проверка `ОписаниеПродукции.Уровень = 0`
- **Требуется**: проверка `УровеньУзла = 1` (как в старом алгоритме)

**Преимущества**:
- Полная идентичность логики со старым алгоритмом
- Минимальное изменение

**Риски**: Низкие

### Вариант 2: Диагностика передачи уровня

**Суть**: Добавить диагностический вывод в журнал регистрации для отслеживания значений `ОписаниеПродукции.Уровень` и `УровеньУзла` на каждом этапе обработки.

**Цель**: Найти точку, где уровень начинает отличаться от ожидаемого.

**Что вывести**:
1. При создании узла для пакетной обработки (строка 3544): значение `ОписаниеПродукции.Уровень`
2. При обработке узла (строки 3877, 3929): значения `Узел.ОписаниеПродукции.Уровень` и вычисленный `УровеньУзла`
3. При создании дочернего узла (строка 4210): значение `УровеньУзла`, которое устанавливается в `НовоеОписаниеПродукции`

**Формат диагностики**: Для каждого узла выводить материал/полуфабрикат и его уровень

### Вариант 3: Анализ конкретного материала

**Суть**: Добавить условную диагностику **только** для проблемного материала "(ОЕМ) Каучук натуральный STR 20".

**Что вывести**:
1. На каком уровне находится этот материал
2. Какое значение `ОписаниеПродукции.Уровень` передаётся
3. Какое значение `ВыводитьДопРасходы` получается
4. Вызывается ли блок запроса дополнительных расходов

---

## Рекомендуемый порядок действий

### Этап 1: Быстрое исправление (Вариант 1)

1. Изменить условие определения `ВыводитьДопРасходы` в новом алгоритме на идентичное старому: проверять `УровеньУзла = 1` вместо `ОписаниеПродукции.Уровень = 0`

2. Протестировать на тех же данных

3. Сравнить результаты:
   - Если совпадают — проблема решена
   - Если не совпадают — перейти к Этапу 2

### Этап 2: Детальная диагностика (если Этап 1 не помог)

1. Реализовать Вариант 3 — диагностику для конкретного материала

2. Проанализировать вывод:
   - На каком уровне материал
   - Какие значения передаются

3. На основе диагностики определить точную причину

### Этап 3: Исправление корневой причины

1. По результатам диагностики внести исправления

2. Удалить диагностический код

3. Финальное тестирование

---

## Критерии успеха

| Критерий | Требование |
|----------|------------|
| Итоговая стоимость | **2 758 680,13 ₽** (идентично старому) |
| Расхождение | **0 ₽** |
| Время выполнения | ≤ 35 сек (сохранить улучшение) |
| Ошибки в журнале | Отсутствуют |

---

## Дополнительные наблюдения

### Количество запросов не сократилось

Несмотря на название "пакетный", алгоритм по-прежнему выполняет **47 запросов** (столько же, сколько старый). Это означает, что функция `СебестоимостьУзловПакетом` **не используется** — каждый узел по-прежнему обрабатывается отдельным вызовом `СебестоимостьУзла`.

**Вывод**: После исправления проблемы с дополнительными расходами необходимо реализовать **настоящую** пакетную обработку для достижения целевого показателя (7 запросов вместо 47).

### Улучшение производительности

Несмотря на то же количество запросов, время сократилось на 17,5%. Возможные причины:
- Отсутствие накладных расходов на глубокую рекурсию
- Более эффективное управление памятью при итеративной обработке по уровням

---

## Решение проблемы с дополнительными расходами (v0.1.0.48)

### Корневая причина

Проблема была **НЕ** в условии `ВыводитьДопРасходы`, как изначально предполагалось. Реальная причина — отчёт "Фактическая себестоимость продукции" обнуляет `ДопРасходы`, если флаги `ТребуетсяРазузлование` или `ТребуетсяРазузлованиеДопРасходов` равны `Истина` (строки 353-357 в `ФСП\ФактическаяСебестоимостьПродукции\Ext\ObjectModule.bsl`):

```sql
СУММА(ВЫБОР
    КОГДА Результат.ТребуетсяРазузлование
     ИЛИ Результат.ТребуетсяРазузлованиеДопРасходов
        ТОГДА 0
    ИНАЧЕ Результат.ДопРасходы
КОНЕЦ) КАК ДопРасходы
```

В новом алгоритме эти флаги не сбрасывались для листовых материалов, в отличие от старого алгоритма.

### Внесённые исправления

#### 1. Установка `ТребуетсяРазузлование = Ложь` для листовых материалов

**Файл:** `CommonModules\СтруктураСебестоимости\Ext\Module.bsl`  
**Строки:** 4152-4153

```bsl
Иначе
    СтрокаПартия.ВидСтроки = Перечисления.ВидыСтрокДереваСебестоимости.ПартияЗатраты;
    СтрокаПартия.ТребуетсяРазузлование = Ложь; // КРИТИЧНО: Добавлено для исправления ДопРасходов в отчете
КонецЕсли;
```

**Аналогия:** Старый алгоритм (строка 424 в `СтруктураСебестоимости.bsl`)

#### 2. Флаг `ЭтоУзелДляДопРасходов` при создании дочернего узла

**Файл:** `CommonModules\СтруктураСебестоимости\Ext\Module.bsl`  
**Строки:** 4343-4344

```bsl
НовыйУзел.Вставить("ЭтоУзелДляДопРасходов", ТекПартия.ТипЗатрат = "ДопРасходы" И НЕ ТекПартия.ТребуетсяРазузлование);
```

**Назначение:** Идентифицирует узлы для дополнительных расходов, которые не требуют дальнейшего разузлования.

#### 3. Логика сброса `ТребуетсяРазузлованиеДопРасходов` в родительской строке

**Файл:** `CommonModules\СтруктураСебестоимости\Ext\Module.bsl`  
**Строки:** 4366-4371

```bsl
// Если это был узел для доп. расходов и он не добавил новых строк,
// то сбрасываем флаг ТребуетсяРазузлованиеДопРасходов в родительской строке.
Если Узел.ЭтоУзелДляДопРасходов
    И Узел.РодительскаяСтрока <> Неопределено
    И КоличествоПосле = КоличествоДо Тогда
    
    Узел.РодительскаяСтрока.ТребуетсяРазузлованиеДопРасходов = Ложь;
КонецЕсли;
```

**Аналогия:** Старый алгоритм (строки 533-538 в `СтруктураСебестоимости.bsl`)

**Логика:** Если узел для доп. расходов не добавил новых строк (разузлование завершено), сбрасываем флаг в родительской строке, чтобы отчёт корректно учитывал `ДопРасходы`.

### Результат

✅ **Проблема полностью решена:**
- Дополнительные расходы для "Каучук натуральный STR 20": **14 890,25 ₽** (совпадает со старым алгоритмом)
- Итоговая стоимость: **2 758 680,13 ₽** (полностью совпадает со старым алгоритмом)
- Расхождение: **0 ₽**

### Версия

**Версия расширения:** `0.1.0.48`  
**Дата исправления:** 21.12.2025

---

## Приоритет задач

| # | Задача | Приоритет | Статус |
|---|--------|-----------|--------|
| 1 | Исправить расхождение в дополнительных расходах | **КРИТИЧЕСКИЙ** | ✅ **ВЫПОЛНЕНО** (v0.1.0.48) |
| 2 | Разделить MCP-инструменты prod_cost / prod_cost_ext | Средний | ✅ **ВЫПОЛНЕНО** (v0.1.1.58) |
| 3 | Реализовать пакетную обработку (7 запросов) | Высокий | ❌ **НЕВОЗМОЖНО** — архитектурное ограничение |
| 4 | Оптимизировать производительность (< 10 сек) | Высокий | ⏳ Заблокировано п.3 |
| 5 | Удалить диагностический код после тестирования | Низкий | ⏳ В работе |

---

## Задача 2: Разделение алгоритмов по отчётам ✅ ВЫПОЛНЕНО

### Результат

**Версия:** `0.1.1.58`  
**Дата:** 21.12.2025

| Отчёт | MCP-инструмент | Алгоритм | Запросов | Время |
|-------|----------------|----------|----------|-------|
| **Типовой** `ФактическаяСебестоимостьПродукции` | `prod_cost` | **СТАРЫЙ** (рекурсивный) | 47 | 27 сек |
| **Новый** `ikon_cost_ФактическаяСебестоимостьПродукции` | `prod_cost_ext` | **НОВЫЙ** (итеративный) | 52 | 32 сек |

### Внесённые изменения

#### 1. Значение по умолчанию изменено на `Ложь`

**Файл**: `CommonModules\СтруктураСебестоимости\Ext\Module.bsl`, строка 19:

```bsl
// ВАЖНО: По умолчанию Ложь для обратной совместимости типового отчёта.
// Новый отчёт ikon_cost_ФактическаяСебестоимостьПродукции явно устанавливает Истина.
ПараметрыДерева.Вставить("ИспользоватьПакетнуюОбработку", Ложь);
```

#### 2. Новый отчёт явно включает новый алгоритм

**Файл**: `Reports\ikon_cost_ФактическаяСебестоимостьПродукции\Ext\ObjectModule.bsl`, строки 136-138:

```bsl
ПараметрыДереваСебестоимости = СтруктураСебестоимости.ПараметрыДереваСебестоимости();
// Явно включаем НОВЫЙ алгоритм (итеративный по уровням) для этого отчёта
ПараметрыДереваСебестоимости.ИспользоватьПакетнуюОбработку = Истина;
```

### Подтверждение из журнала регистрации

**`prod_cost` (типовой отчёт) — 23:37:08:**
```
Алгоритм: СТАРЫЙ (рекурсивный)
ИспользоватьПакетнуюОбработку=Нет
Запросов к БД: 47
Время: 27 сек
```

**`prod_cost_ext` (новый отчёт) — 23:37:36:**
```
Алгоритм: НОВЫЙ (пакетный)
ИспользоватьПакетнуюОбработку=Да
Запросов к БД: 52
Уровней дерева: 7
Время: 32 сек
```

### Преимущества решения

1. ✅ **Нет новых параметров** — выбор алгоритма определяется выбором отчёта
2. ✅ **Обратная совместимость** — типовой отчёт работает как раньше
3. ✅ **Изолированное тестирование** — можно сравнивать результаты двух отчётов
4. ✅ **Простота** — минимальные изменения в коде (2 строки)
5. ✅ **Откат** — при проблемах достаточно использовать типовой отчёт

### Схема работы

```
                    ┌─────────────────────────────────────┐
                    │   СтруктураСебестоимости.           │
                    │   ПараметрыДереваСебестоимости()    │
                    │                                     │
                    │   ИспользоватьПакетнуюОбработку     │
                    │   = Ложь (по умолчанию)             │
                    └──────────────┬──────────────────────┘
                                   │
              ┌────────────────────┴────────────────────┐
              │                                         │
              ▼                                         ▼
┌─────────────────────────────┐     ┌──────────────────────────────────────┐
│ Типовой отчёт               │     │ Новый отчёт                          │
│ ФактическаяСебестоимость    │     │ ikon_cost_ФактическаяСебестоимость   │
│ Продукции                   │     │ Продукции                            │
│                             │     │                                      │
│ Использует значение         │     │ Переопределяет:                      │
│ по умолчанию: Ложь          │     │ ИспользоватьПакетнуюОбработку        │
│                             │     │ = Истина                             │
│         ▼                   │     │         ▼                            │
│   СТАРЫЙ АЛГОРИТМ           │     │   НОВЫЙ АЛГОРИТМ                     │
│   (рекурсивный)             │     │   (итеративный по уровням)           │
└─────────────────────────────┘     └──────────────────────────────────────┘
              │                                         │
              ▼                                         ▼
        prod_cost                               prod_cost_ext
        (MCP-инструмент)                        (MCP-инструмент)
```

### Ожидаемый результат

```bash
# Вызов типового отчёта → старый алгоритм (эталон)
> prod_cost --startDate 2025-01-01 --endDate 2025-12-31
Итого: 2 758 680,13 ₽  (40 сек, 47 запросов)

# Вызов нового отчёта → новый алгоритм
> prod_cost_ext --startDate 2025-01-01 --endDate 2025-12-31
Итого: 2 758 680,13 ₽  (цель: < 10 сек, 7 запросов) ✅ Совпадает
```

### Итоговая производительность (v0.1.1.60)

| Метрика | Значение | Сравнение со старым |
|---------|----------|---------------------|
| Время выполнения | ~30 сек | -25% |
| Запросов к БД | **47** | 0% (без изменений) |
| Корректность | **100%** | ✅ **Эталон** |
| Алгоритм | Итеративный по уровням | Без рекурсии |

**Версия расширения:** `0.1.1.60`  
**Дата обновления:** 22.12.2025

#### Почему пакетная обработка (7 запросов) невозможна

Попытка реализовать пакетную обработку (v0.1.1.59) показала **фундаментальное архитектурное ограничение**.

##### Корневая причина: отсутствие пропорции в таблице узлов

При разузловании каждый узел дерева себестоимости связан с родительским узлом через **пропорцию использования** — какая доля себестоимости дочерней партии должна быть отнесена на родительскую партию.

**Пропорция** = `Числитель / Знаменатель`, где:
- `Числитель` — количество материала/полуфабриката, использованное на выпуск родительской партии
- `Знаменатель` — общее количество выпуска дочерней партии

**Анализ запроса** (`Запрос_001.sql`):

1. **Фильтр `ВТПарыУзлов`** (строки 81-82) содержит **только идентификаторы** партий:
   ```sql
   И (СебестоимостьТоваров.Партия, СебестоимостьТоваров.АналитикаУчетаПартий) В 
       (ВЫБРАТЬ ВТПарыУзлов.ПартияПродукции, ВТПарыУзлов.АналитикаУчетаПартийПродукции 
        ИЗ ВТПарыУзлов КАК ВТПарыУзлов)
   ```
   
   **Проблема**: В `ВТПарыУзлов` **НЕ передаётся пропорция использования** партий на выпуск предыдущего шага (родительского узла).

2. **Пропорция передаётся через глобальные параметры** (строки 183-207):
   ```sql
   КОГДА &Числитель = 0 ТОГДА СУММА(...) ИНАЧЕ &Числитель КОНЕЦ КАК Числитель,
   КОГДА &Знаменатель = 0 ТОГДА СУММА(...) ИНАЧЕ &Знаменатель КОНЕЦ КАК Знаменатель,
   ```

3. **Все суммы умножаются на пропорцию** (строки 872-975):
   ```sql
   ВтПродукция.Материальные * ВтПродукция.Числитель / ВтПродукция.Знаменатель КАК Материальные,
   ВтПродукция.Трудозатраты * ВтПродукция.Числитель / ВтПродукция.Знаменатель КАК Трудозатраты,
   ...
   ```

##### Объединение запросов одного уровня: возможный подход

При обработке нескольких узлов одного уровня в одном запросе:

| Узел | ПартияПродукции | Числитель | Знаменатель | Пропорция |
|------|-----------------|-----------|-------------|-----------|
| A | Партия_001 | 100 | 500 | **20%** |
| B | Партия_001 | 50 | 500 | **10%** |
| C | Партия_002 | 200 | 200 | **100%** |

**Решение**: Узлы с одинаковой партией можно **сгруппировать**:

| Группа | ПартияПродукции | СуммаЧислителей | Знаменатель | ОбщаяПропорция |
|--------|-----------------|-----------------|-------------|----------------|
| A+B | Партия_001 | **150** | 500 | **30%** |
| C | Партия_002 | 200 | 200 | **100%** |

**Алгоритм**:
1. **Группировка**: `СУММА(Числитель)`, `МАКСИМУМ(Знаменатель)` по ключу `(ПартияПродукции, АналитикаУчетаПартий)`
2. **Запрос**: Получить себестоимость сгруппированных партий одним запросом
3. **Пост-распределение**: Разделить результат обратно по узлам пропорционально их исходным числителям

**Пример пост-распределения**:
- Запрос вернул: себестоимость Партия_001 × 30% = **15 000 ₽**
- Узел A получает: 15 000 × (100 / 150) = **10 000 ₽**
- Узел B получает: 15 000 × (50 / 150) = **5 000 ₽**

##### Почему пакетная обработка пока не реализована

Несмотря на возможность группировки, реализация требует:

1. **Двухэтапной обработки**: сначала группировка для запроса, затем распределение результата
2. **Сохранения маппинга**: какие исходные узлы входят в каждую группу и с какими весами
3. **Модификации СКД**: замена глобальных параметров на поля временной таблицы
4. **Тестирования**: проверка корректности на всех сценариях (включая встречные выпуски)

##### Следствия (пересмотрены с учётом передачи пропорций)

| Проблема | Текущее состояние | Решение | Статус |
|----------|-------------------|---------|--------|
| **Декартово умножение** | Данные дублируются при распределении | Группировка партий + пост-распределение по весам | ✅ Решаемо |
| **Распределение по узлам** | Невозможно определить принадлежность | Сохранение маппинга узлов к группам | ✅ Решаемо |
| **Индивидуальные коэффициенты** | Глобальные параметры `&Числитель/&Знаменатель` | Поля таблицы `ВТУзлыУровня.Числитель/Знаменатель` | ✅ Решаемо |

##### Как снимаются проблемы

**1. Декартово умножение → Группировка + пост-распределение**

| Этап | Действие |
|------|----------|
| Подготовка | Группировка узлов по `(ПартияПродукции, АналитикаУчетаПартий)` с `СУММА(Числитель)`, `МАКС(Знаменатель)` |
| Запрос | Один запрос для всех уникальных партий уровня |
| Результат | Себестоимость каждой партии × групповая пропорция |
| Распределение | Разделение по узлам пропорционально их `Числитель / СуммаЧислителейГруппы` |

**2. Распределение по узлам → Маппинг**

Перед запросом сохраняется структура:
```
Группа "Партия_001" → [
    {Узел: A, Числитель: 100, Вес: 100/150 = 66.7%},
    {Узел: B, Числитель: 50,  Вес: 50/150  = 33.3%}
]
```

После запроса: `РезультатУзла = РезультатГруппы × ВесУзла`

**3. Индивидуальные коэффициенты → Поля таблицы**

| Было (глобальные параметры) | Станет (поля таблицы) |
|-----------------------------|----------------------|
| `&Числитель / &Знаменатель` | `ВТУзлыУровня.Числитель / ВТУзлыУровня.Знаменатель` |
| Один коэффициент на весь запрос | Индивидуальный коэффициент для каждой строки |

##### Требования к реализации

1. **Формирование `ВТУзлыУровня`**: Временная таблица со всеми узлами уровня, включая:
   - `ПартияПродукции`
   - `АналитикаУчетаПартий`
   - `Числитель` (сумма по группе)
   - `Знаменатель` (максимум по группе)

2. **Маппинг для пост-распределения**: Соответствие, хранящее для каждой группы список исходных узлов с их весами

3. **Модификация СКД**: Замена `&Числитель`, `&Знаменатель` на `JOIN` с `ВТУзлыУровня`

4. **Пост-обработка результата**: Распределение строк результата по исходным узлам согласно маппингу

**Результат v0.1.1.59**: сумма **32.5M ₽** вместо эталонных **2.9M ₽** (завышение в ~11 раз из-за дублирования данных)

---

## Задача 2: Пакетная обработка (ЗАБЛОКИРОВАНО — архитектурное ограничение)

### Ресурсы для модификации

В проект добавлен отчёт расширения, позволяющий модифицировать СКД:

| Файл | Назначение |
|------|------------|
| `Reports\ikon_cost_ФактическаяСебестоимостьПродукции.xml` | Метаданные отчёта |
| `Reports\...\Ext\ObjectModule.bsl` | Модуль объекта отчёта |
| `Reports\...\Templates\ОсновнаяСхемаКомпоновкиДанных\Ext\Template.xml` | **СКД с запросами** |

### Суть проблемы (детальный анализ)

#### Текущая архитектура запросов

1. **Фильтрация узлов** — через временную таблицу `ВТПарыУзлов`, которая содержит **только идентификаторы**:
   - `ПартияПродукции`
   - `АналитикаУчетаПартийПродукции`
   
   **Пропорция использования партий (`Числитель/Знаменатель`) НЕ включена в таблицу.**

2. **Пропорция распределения** — передаётся через **глобальные параметры**:
   - `&Числитель` — количество использованное на родительский выпуск
   - `&Знаменатель` — общее количество выпуска дочерней партии
   
3. **Расчёт себестоимости** — все суммы умножаются на пропорцию:
   ```sql
   Материальные * Числитель / Знаменатель КАК Материальные
   ```

#### Почему это блокирует пакетную обработку

При обработке **нескольких узлов одного уровня** каждый узел связан с родителем через **свою уникальную пропорцию**.

**Пример:**
- Узел A использует 100 кг из партии X (из 500 кг общего выпуска) → пропорция **20%**
- Узел B использует 50 кг из той же партии X (из 500 кг) → пропорция **10%**

При объединении в один запрос:
1. Запрос возвращает себестоимость партии X **один раз**
2. Без индивидуальной пропорции для каждого узла **невозможно** корректно распределить 20% на узел A и 10% на узел B
3. Результат: либо дублирование (100% + 100% = 200%), либо потеря данных

#### Требуемое решение (если возможно)

Для реализации пакетной обработки необходимо:

1. **Включить пропорцию в таблицу узлов** `ВТПарыУзлов`:
   - Добавить поля `Числитель` и `Знаменатель`
   - Добавить идентификатор родительского узла для связи

2. **Модифицировать запросы** — заменить глобальные параметры на поля таблицы:
   - **Было**: `&Числитель / &Знаменатель`
   - **Требуется**: `ВТПарыУзлов.Числитель / ВТПарыУзлов.Знаменатель`

3. **Изменить JOIN** — связывать результаты не только по партии, но и по родительскому узлу

**Статус**: Требуется глубокая модификация СКД и логики формирования временных таблиц.

### Требуемые изменения

#### Этап 2.1: Подготовка временной таблицы узлов

**Место**: `CommonModules\СтруктураСебестоимости\Ext\Module.bsl`, функция `РазузловатьУзлыПакетом`

**Что сделать**:
1. Перед выполнением запроса создать временную таблицу `ВТУзлыУровня` со структурой:
   - `ПартияПродукции` (ссылка)
   - `АналитикаУчетаПартийПродукции` (ссылка)
   - `Числитель` (число)
   - `Знаменатель` (число)
   - `КоличествоПродукции` (число)

2. Заполнить таблицу данными **всех узлов** текущего уровня

3. Передать временную таблицу в запрос через менеджер временных таблиц

#### Этап 2.2: Модификация СКД

**Место**: `Reports\...\Templates\ОсновнаяСхемаКомпоновкиДанных\Ext\Template.xml`

**Что сделать**:
1. Добавить JOIN с временной таблицей `ВТУзлыУровня` по полям `ПартияПродукции` и `АналитикаУчетаПартийПродукции`

2. Заменить параметры `&Числитель`, `&Знаменатель`, `&КоличествоПродукции` на поля из временной таблицы:
   - **Было**: `&Числитель / &Знаменатель`
   - **Требуется**: `ВТУзлыУровня.Числитель / ВТУзлыУровня.Знаменатель`

3. Модифицировать все формулы расчёта затрат, использующие эти параметры

#### Этап 2.3: Адаптация вызова запроса

**Место**: `CommonModules\СтруктураСебестоимости\Ext\Module.bsl`

**Что сделать**:
1. Использовать функцию `СебестоимостьУзловПакетом` вместо `СебестоимостьУзла`

2. Передавать менеджер временных таблиц с заполненной `ВТУзлыУровня`

3. Распределять результаты по узлам после выполнения запроса

### Результат исследования (v0.1.1.60)

| Метрика | До оптимизации | После попытки | Итог |
|---------|----------------|---------------|------|
| Количество запросов | 47 | 7 (v0.1.1.59) | **47** (откат) |
| Время выполнения | 52 сек | 9 сек (некорректно) | **~30 сек** |
| Корректность | ✅ 100% | ❌ Завышение 11x | ✅ 100% |
| Алгоритм | Рекурсивный | Пакетный JOIN | **Итеративный** |

**Вывод:** Пакетная обработка невозможна. Итеративный алгоритм быстрее рекурсивного на ~25% без изменения количества запросов.

**Дата обновления:** 22.12.2025

### Риски

| Риск | Вероятность | Митигация |
|------|-------------|-----------|
| Изменение результатов из-за модификации запросов | Средняя | Сравнение с эталоном после каждого изменения |
| Сложность распределения результатов по узлам | Средняя | Добавление ключевых полей для идентификации |
| Влияние на другие варианты отчёта | Низкая | Отдельный отчёт в расширении |

### Порядок выполнения

1. **Анализ СКД**: Изучить структуру запросов, найти все места использования `&Числитель`, `&Знаменатель`, `&КоличествоПродукции`

2. **Прототип**: Создать тестовый запрос с JOIN временной таблицы на одном уровне

3. **Проверка корректности**: Сравнить результаты прототипа с эталоном

4. **Полная реализация**: Внести изменения во все запросы СКД

5. **Интеграция**: Подключить пакетную обработку в `РазузловатьУзлыПакетом`

6. **Финальное тестирование**: Полное сравнение с эталоном, замеры производительности
