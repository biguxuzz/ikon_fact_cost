# Анализ алгоритмов разузлования себестоимости

## Обзор

Модуль `СтруктураСебестоимости` содержит два алгоритма для построения дерева себестоимости продукции:

1. **Старый алгоритм** (рекурсивный) — оригинальный типовой алгоритм 1С:ERP
2. **Новый алгоритм** (пакетный) — оптимизированная версия для решения проблемы N+1 запросов

Переключение между алгоритмами осуществляется параметром:
```bsl
ПараметрыДерева.Вставить("ИспользоватьПакетнуюОбработку", Истина/Ложь);
```

---

## Старый алгоритм (рекурсивный)

### Принцип работы

```
ЗаполнитьДеревоСебестоимости()
    ├── Запрос выпущенной продукции (уровень 0)
    └── Для каждой продукции:
            └── РазузловатьУзелДереваСебестоимости() ← рекурсия
                    ├── Запрос затрат для узла
                    └── Для каждой затраты-полуфабриката:
                            └── РазузловатьУзелДереваСебестоимости() ← рекурсия
                                    └── ...
```

### Ключевые особенности

1. **Рекурсивный обход**: Каждый полуфабрикат разузловывается отдельным рекурсивным вызовом

2. **Передача `ОписаниеПродукции`**: Структура передаётся **неизменной** через все уровни рекурсии:

```bsl
// Строка 383-386 в СтруктураСебестоимости.bsl
АналитикаУчетаПродукции       = ОписаниеПродукции.АналитикаУчетаПродукции;
ПартияПродукции               = ОписаниеПродукции.ПартияПродукции;
АналитикаУчетаПартийПродукции = ОписаниеПродукции.АналитикаУчетаПартийПродукции;
УровеньУзла                   = ОписаниеПродукции.Уровень + 1;
```

3. **Заполнение полей связи с корневой продукцией** (строки 427-429):

```bsl
СтрокаПартия.АналитикаУчетаПродукции      = АналитикаУчетаПродукции;      // ← из ОписаниеПродукции
СтрокаПартия.ПартияПродукции              = ПартияПродукции;              // ← из ОписаниеПродукции
СтрокаПартия.АналитикаУчетаПартийПродукции = АналитикаУчетаПартийПродукции; // ← из ОписаниеПродукции
```

4. **Обновление только уровня** при рекурсивном вызове (строка 527):

```bsl
ОписаниеПродукции.Вставить("Уровень", УровеньУзла);
РазузловатьУзелДереваСебестоимости(ПараметрыДерева, ПараметрыУзлаПартии, ТаблицаРезультатаПартии, ОписаниеПродукции);
```

### Недостаток

**Проблема N+1 запросов**: Для каждого полуфабриката выполняется отдельный запрос к базе данных. При глубокой иерархии и большом количестве полуфабрикатов это приводит к значительным задержкам.

---

## Новый алгоритм (пакетный)

### Принцип работы

```
ЗаполнитьДеревоСебестоимости()
    ├── Запрос выпущенной продукции (уровень 0)
    ├── Сбор узлов уровня 1 в массив УзлыДляПакетнойОбработки
    └── Цикл обработки по уровням:
            Пока УзлыТекущегоУровня.Количество() > 0:
                └── РазузловатьУзлыПакетом()
                        ├── Для каждого узла: СебестоимостьУзла()
                        ├── ОбработатьРезультатыУзла()
                        └── Возврат УзлыСледующегоУровня
```

### Ключевые особенности

1. **Итеративный обход по уровням**: Вместо рекурсии используется цикл `Пока`, который последовательно обрабатывает каждый уровень дерева

2. **Сохранение данных корневой продукции**: В исправленной версии данные корневой продукции передаются через все уровни:

```bsl
// Строки 975-977 (исправленная версия)
СтрокаПартия.ПартияПродукции              = ПартияПродукции;              // ← из ОписаниеПродукции
СтрокаПартия.АналитикаУчетаПартийПродукции = АналитикаУчетаПартийПродукции; // ← из ОписаниеПродукции  
СтрокаПартия.АналитикаУчетаПродукции      = АналитикаУчетаПродукции;      // ← из ОписаниеПродукции

// Строки 987-989 (исправленная версия)
СтрокаПартия.ПартияВыходноеИзделие               = ПартияПродукции;
СтрокаПартия.АналитикаУчетаПартийВыходноеИзделие = АналитикаУчетаПартийПродукции;
СтрокаПартия.АналитикаУчетаВыходноеИзделие       = АналитикаУчетаПродукции;
```

3. **Передача данных корневой продукции на следующий уровень** (строки 1086-1090):

```bsl
НовоеОписаниеПродукции = Новый Структура("АналитикаУчетаПродукции, ПартияПродукции, АналитикаУчетаПартийПродукции");
НовоеОписаниеПродукции.АналитикаУчетаПродукции      = АналитикаУчетаПродукции;      // ← корневая!
НовоеОписаниеПродукции.ПартияПродукции              = ПартияПродукции;              // ← корневая!
НовоеОписаниеПродукции.АналитикаУчетаПартийПродукции = АналитикаУчетаПартийПродукции; // ← корневая!
НовоеОписаниеПродукции.Вставить("Уровень", УровеньУзла);
```

### Преимущество

Значительное сокращение количества обращений к базе данных за счёт обработки узлов пакетами по уровням.

---

## Ошибка в ветке `init`

### Описание проблемы

В начальной версии нового алгоритма (коммит `a5cb3f4`) была допущена критическая ошибка: **данные для связи с продукцией брались из текущего уровня вместо корневой продукции**.

### Код с ошибкой (ветка init)

```bsl
// ОШИБКА: данные из ТекПартия (текущий уровень)
СтрокаПартия.ПартияПродукции              = ТекПартия.ПартияВыходноеИзделие;
СтрокаПартия.АналитикаУчетаПартийПродукции = ТекПартия.АналитикаУчетаПартийВыходноеИзделие;
СтрокаПартия.АналитикаУчетаПродукции      = ТекПартия.АналитикаУчетаВыходноеИзделие;

// ОШИБКА: данные из ТекПартия для следующего уровня
НовоеОписаниеПродукции.АналитикаУчетаПродукции      = ТекПартия.АналитикаУчетаЗатрата;
НовоеОписаниеПродукции.ПартияПродукции              = ТекПартия.ПартияЗатрата;
НовоеОписаниеПродукции.АналитикаУчетаПартийПродукции = ТекПартия.АналитикаУчетаПартийЗатрата;
```

### Исправленный код

```bsl
// ПРАВИЛЬНО: данные из ОписаниеПродукции (корневая продукция)
СтрокаПартия.ПартияПродукции              = ПартияПродукции;              // ОписаниеПродукции.ПартияПродукции
СтрокаПартия.АналитикаУчетаПартийПродукции = АналитикаУчетаПартийПродукции;
СтрокаПартия.АналитикаУчетаПродукции      = АналитикаУчетаПродукции;

// ПРАВИЛЬНО: данные корневой продукции для следующего уровня
НовоеОписаниеПродукции.АналитикаУчетаПродукции      = АналитикаУчетаПродукции;
НовоеОписаниеПродукции.ПартияПродукции              = ПартияПродукции;
НовоеОписаниеПродукции.АналитикаУчетаПартийПродукции = АналитикаУчетаПартийПродукции;
```

---

## Почему в отчёте выводились только статьи калькуляции?

### Механизм формирования отчёта

Отчёт о фактической себестоимости строит связь между продукцией и её затратами через соединение (JOIN):

```sql
ВТПродукция.ПартияПродукции = ВТЗатраты.ПартияПродукции
```

Это соединение позволяет связать каждый материал/полуфабрикат с корневой продукцией, в себестоимость которой он входит.

### Что происходило в версии с ошибкой

#### Уровень 0 (корневая продукция)
Добавляется в `ЗаполнитьДеревоСебестоимости()` — поля заполняются корректно из запроса:
```
Продукция "Готовое изделие А"
├── ПартияПродукции = Партия_А (корневая)
└── Статьи калькуляции (уровень 1) - работают корректно
```

#### Уровень 1+ (материалы и полуфабрикаты)
Добавляются в `ОбработатьРезультатыУзла()` — с ошибкой:

```
Материал "Сталь"
├── ПартияПродукции = Партия_ПФ_1 (ОШИБКА! Это партия полуфабриката)
└── Должно быть: ПартияПродукции = Партия_А (корневая продукция)
```

### Результат ошибки

```
Продукция "Готовое изделие А" (Партия_А)
    │
    ├── JOIN по ПартияПродукции = Партия_А
    │       │
    │       ├── Статьи калькуляции ✓ (ПартияПродукции = Партия_А)
    │       │
    │       └── Материалы ✗ (ПартияПродукции = Партия_ПФ_1 ≠ Партия_А)
    │
    └── Материалы "висят в воздухе" — нет связи с корневой продукцией
```

### Почему статьи калькуляции работали?

Статьи калькуляции добавляются **на уровне 0** в процедуре `ЗаполнитьДеревоСебестоимости()`, где:
1. `ОписаниеПродукции` создаётся заново для каждой корневой продукции
2. Поля `ПартияПродукции` заполняются из запроса корневой продукции
3. Соединение `ВТПродукция.ПартияПродукции = Затраты.ПартияПродукции` работает корректно

### Почему материалы не выводились?

Материалы добавляются **на уровнях 1+** в процедуре `ОбработатьРезультатыУзла()`, где в версии с ошибкой:
1. `ПартияПродукции` заполнялась из `ТекПартия.ПартияВыходноеИзделие` — партия **промежуточного полуфабриката**
2. При соединении `ВТПродукция.ПартияПродукции = Затраты.ПартияПродукции`:
   - `ВТПродукция.ПартияПродукции` = партия корневой продукции (Партия_А)
   - `Затраты.ПартияПродукции` = партия полуфабриката (Партия_ПФ_1)
   - **Соединение не срабатывает!**
3. Материалы выпадают из результата отчёта

---

## Схема потока данных

### Старый алгоритм (корректный)

```
┌─────────────────────────────────────────────────────────────────────┐
│ ОписаниеПродукции = {                                               │
│   АналитикаУчетаПродукции: "Аналитика_КорневойПродукции",          │
│   ПартияПродукции: "Партия_КорневойПродукции",                      │
│   Уровень: 0                                                         │
│ }                                                                    │
└─────────────────────────────────────────────────────────────────────┘
                              │
                              ▼ (передаётся неизменным!)
┌─────────────────────────────────────────────────────────────────────┐
│ Уровень 1: Полуфабрикат                                             │
│   СтрокаПартия.ПартияПродукции = ОписаниеПродукции.ПартияПродукции  │
│   (Партия КОРНЕВОЙ продукции)                                       │
└─────────────────────────────────────────────────────────────────────┘
                              │
                              ▼ (передаётся неизменным!)
┌─────────────────────────────────────────────────────────────────────┐
│ Уровень 2: Материал                                                 │
│   СтрокаПартия.ПартияПродукции = ОписаниеПродукции.ПартияПродукции  │
│   (Партия КОРНЕВОЙ продукции)                                       │
└─────────────────────────────────────────────────────────────────────┘
```

### Новый алгоритм в ветке init (с ошибкой)

```
┌─────────────────────────────────────────────────────────────────────┐
│ ОписаниеПродукции = {                                               │
│   АналитикаУчетаПродукции: "Аналитика_КорневойПродукции",          │
│   ПартияПродукции: "Партия_КорневойПродукции",                      │
│   Уровень: 0                                                         │
│ }                                                                    │
└─────────────────────────────────────────────────────────────────────┘
                              │
                              ▼ (ОШИБКА: создаётся новое!)
┌─────────────────────────────────────────────────────────────────────┐
│ Уровень 1: Полуфабрикат                                             │
│   СтрокаПартия.ПартияПродукции = ТекПартия.ПартияВыходноеИзделие    │
│   (Партия ТЕКУЩЕГО полуфабриката) ← ОШИБКА!                         │
│                                                                      │
│   НовоеОписаниеПродукции.ПартияПродукции = ТекПартия.ПартияЗатрата │
│   (Данные ТЕКУЩЕГО уровня) ← ОШИБКА!                                │
└─────────────────────────────────────────────────────────────────────┘
                              │
                              ▼ (уже неправильные данные)
┌─────────────────────────────────────────────────────────────────────┐
│ Уровень 2: Материал                                                 │
│   СтрокаПартия.ПартияПродукции = ??? (потеряна связь с корневой)   │
└─────────────────────────────────────────────────────────────────────┘
```

---

## Защита от встречных (циклических) выпусков

### Что такое встречный выпуск?

Встречный выпуск — это ситуация, когда полуфабрикат А входит в состав полуфабриката Б, а полуфабрикат Б входит в состав полуфабриката А (прямо или через цепочку других полуфабрикатов).

```
Пример циклической зависимости:
ПФ_А → ПФ_Б → ПФ_В → ПФ_А (цикл!)
```

Без защиты это приводит к бесконечной рекурсии и падению системы.

### Механизм защиты: таблица `ПройденныйПуть`

Оба алгоритма используют таблицу `ПройденныйПуть` для отслеживания уже обработанных партий:

```bsl
// Инициализация (строки 374-380 в старом, 113-119 в новом)
ПройденныйПуть = Новый ТаблицаЗначений;
ПройденныйПуть.Колонки.Добавить("Партия");
ПройденныйПуть.Колонки.Добавить("АналитикаУчетаПартий");
ПройденныйПуть.Индексы.Добавить("Партия, АналитикаУчетаПартий");
```

### Проверка на цикл

При обработке каждой затраты проверяется, была ли партия уже в пути:

```bsl
// Проверка перед разузлованием
Если ТекПартия.ТребуетсяРазузлование И ТекПартия.КоличествоЗатрата <> 0 Тогда
    ПараметрыОтбора = Новый Структура("Партия, АналитикаУчетаПартий",
        ТекПартия.ПартияЗатрата,
        ТекПартия.АналитикаУчетаПартийЗатрата);
    МассивСтрок = ПройденныйПуть.НайтиСтроки(ПараметрыОтбора);
КонецЕсли;

// Если МассивСтрок.Количество() > 0 — обнаружен цикл!
// Разузлование этой партии НЕ выполняется
```

### Ключевое различие между алгоритмами

#### Старый алгоритм: УДАЛЯЕТ партии после разузлования

```bsl
// Строки 541-552 в СтруктураСебестоимости.bsl
// Удалим строку, по которой уже выполнено разузлование.
Если ТекПартия.ТребуетсяРазузлование
    И Окр(ТекПартия.КоличествоЗатрата, 3) <> 0
    И ТекПартия.СуммаЗатрата <> 0 Тогда
    ПараметрыОтбора = Новый Структура("Партия, АналитикаУчетаПартий", ...);
    МассивСтрок = ПройденныйПуть.НайтиСтроки(ПараметрыОтбора);
    Для Каждого СтрокаКУдалению Из МассивСтрок Цикл
        ПройденныйПуть.Удалить(СтрокаКУдалению);  // ← УДАЛЕНИЕ!
    КонецЦикла;
КонецЕсли;
```

**Проблема**: После удаления партия может снова попасть в обработку по другому пути, что может привести к пропуску некоторых сложных циклов или дублированию данных.

#### Новый алгоритм: НЕ удаляет партии

```bsl
// Строки 331-349 в Module.bsl
#Вставка
// УБРАНА логика удаления из ПройденныйПуть для предотвращения встречных циклов.
// Партии остаются в ПройденныйПуть на протяжении всего процесса построения дерева,
// что обеспечивает корректное обнаружение циклических зависимостей любой сложности.
#КонецВставки
#Удаление
// Удалим строку, по которой уже выполнено разузлование.
// ... (код удаления закомментирован)
#КонецУдаления
```

### Дополнительные механизмы защиты в новом алгоритме

#### 1. Ограничение глубины рекурсии

```bsl
// Строки 121-123
ПараметрыДерева.Вставить("МаксимальнаяГлубинаРекурсии", 50);
ПараметрыДерева.Вставить("ОбнаруженныеЦиклы", Новый Массив);

// Проверка (строки 132-146)
Если УровеньУзла > ПараметрыДерева.МаксимальнаяГлубинаРекурсии Тогда
    ЗаписьЖурналаРегистрации(
        "СтруктураСебестоимости.МаксимальнаяГлубинаРекурсии",
        УровеньЖурналаРегистрации.Предупреждение, ...);
    Возврат;  // Прерывание разузлования
КонецЕсли;
```

#### 2. Логирование обнаруженных циклов

```bsl
// Строки 165-191
Если МассивСтрок.Количество() > 0 Тогда
    ИнформацияОЦикле = Новый Структура;
    ИнформацияОЦикле.Вставить("Уровень", УровеньУзла);
    ИнформацияОЦикле.Вставить("ПартияЗатрата", ТекПартия.ПартияЗатрата);
    ИнформацияОЦикле.Вставить("Затрата", ТекПартия.Затрата);
    // ...
    
    ПараметрыДерева.ОбнаруженныеЦиклы.Добавить(ИнформацияОЦикле);
    
    ЗаписьЖурналаРегистрации(
        "СтруктураСебестоимости.ОбнаруженЦикл",
        УровеньЖурналаРегистрации.Предупреждение, ...);
КонецЕсли;
```

#### 3. Статистика по циклам в конце обработки

```bsl
// Строки 79-92
Если ПараметрыДерева.Свойство("ОбнаруженныеЦиклы") 
    И ПараметрыДерева.ОбнаруженныеЦиклы.Количество() > 0 Тогда
    
    ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
        "При построении дерева себестоимости обнаружено циклических зависимостей: %1",
        Строка(ПараметрыДерева.ОбнаруженныеЦиклы.Количество()));
    ЗаписьЖурналаРегистрации(
        "СтруктураСебестоимости.СтатистикаЦиклов",
        УровеньЖурналаРегистрации.Предупреждение, ...);
КонецЕсли;
```

### Сравнительная таблица

| Механизм | Старый алгоритм | Новый алгоритм |
|----------|----------------|----------------|
| Таблица `ПройденныйПуть` | ✅ Есть | ✅ Есть |
| Удаление после обработки | ✅ Да (потенциальная уязвимость) | ❌ Нет |
| Ограничение глубины | ❌ Нет | ✅ 50 уровней |
| Логирование циклов | ❌ Нет | ✅ В журнал регистрации |
| Сбор статистики | ❌ Нет | ✅ Массив `ОбнаруженныеЦиклы` |

### Пример встречного выпуска

```
Продукция: "Станок" (Партия_С)
    ├── Полуфабрикат: "Корпус" (Партия_К)
    │       ├── Материал: "Сталь"
    │       └── Полуфабрикат: "Втулка" (Партия_В)
    │               ├── Материал: "Бронза"
    │               └── Полуфабрикат: "Корпус" (Партия_К) ← ЦИКЛ!
    │                       └── [Разузлование прервано]
    └── ...
```

При обнаружении цикла:
1. Партия "Корпус" уже есть в `ПройденныйПуть`
2. Разузлование НЕ выполняется
3. В журнал записывается предупреждение
4. Затрата добавляется как `ПартияЗатраты` (без дальнейшего разузлования)

---

## Выводы

1. **Ключевой принцип**: Поле `ПартияПродукции` должно содержать ссылку на **корневую продукцию** на ВСЕХ уровнях разузлования

2. **Причина ошибки в init**: В новом алгоритме ошибочно использовались данные текущего уровня (`ТекПартия`) вместо данных корневой продукции (`ОписаниеПродукции`)

3. **Следствие**: Соединение в отчёте `ВТПродукция.ПартияПродукции = Затраты.ПартияПродукции` не работало для материалов глубоких уровней

4. **Исправление**: Передача данных корневой продукции через все уровни обработки, аналогично старому рекурсивному алгоритму

5. **Защита от встречных выпусков**: 
   - Оба алгоритма используют таблицу `ПройденныйПуть` для отслеживания обработанных партий
   - **Старый алгоритм**: удаляет партии после обработки (потенциальная уязвимость к сложным циклам)
   - **Новый алгоритм**: партии остаются в `ПройденныйПуть` навсегда, добавлены ограничение глубины (50 уровней) и логирование в журнал регистрации
