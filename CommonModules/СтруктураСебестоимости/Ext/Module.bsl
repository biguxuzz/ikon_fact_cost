&ИзменениеИКонтроль("ПараметрыДереваСебестоимости")
Функция ikon_cost_ПараметрыДереваСебестоимости() Экспорт
	
	ТипыРезультата = Новый ОписаниеТипов("ДеревоЗначений,ТаблицаЗначений,МенеджерВременныхТаблиц");
	
	ПараметрыДерева = Новый Структура;
	
	ПараметрыДерева.Вставить("ДинамическоеСчитывание",	Истина);
	ПараметрыДерева.Вставить("ТипРезультата",			"ДеревоЗначений");
	ПараметрыДерева.Вставить("Результат",				ТипыРезультата.ПривестиЗначение(Неопределено));
	ПараметрыДерева.Вставить("ДобавлятьПолуфабрикатыВРезультат", Истина);
	
	#Вставка
	// === НАСТРОЙКИ ОПТИМИЗАЦИИ И ДИАГНОСТИКИ ===
	
	// Использовать пакетную обработку узлов по уровням (оптимизация N+1)
	// При Истина - узлы обрабатываются пакетами по уровням (быстрее, меньше запросов)
	// При Ложь - классический рекурсивный алгоритм (совместимость)
	ПараметрыДерева.Вставить("ИспользоватьПакетнуюОбработку", Истина);
	
	// Включить диагностические сообщения в журнал регистрации
	// При Истина - выводятся подробные логи обработки (для отладки)
	// При Ложь - диагностика отключена (рекомендуется для продакшена)
	// ПРИМЕЧАНИЕ: Основные "тяжёлые" блоки диагностики (с запросами и циклами) 
	//             обёрнуты в проверку этого флага. Простые записи в журнал 
	//             можно обернуть дополнительно при необходимости.
	ПараметрыДерева.Вставить("ВыводитьДиагностику", Ложь);
	ПараметрыДерева.Вставить("СчётчикДиагностикиПартий", 0); // Счётчик для ограничения вывода
 	#КонецВставки

	Возврат ПараметрыДерева;

КонецФункции

&ИзменениеИКонтроль("ПостроитьДеревоСебестоимости")
Процедура ikon_cost_ПостроитьДеревоСебестоимости(ПараметрыДерева, ПараметрыУзла = Неопределено) Экспорт

	#Вставка
	// КРИТИЧНО: Для отчётов (МенеджерВременныхТаблиц) полуфабрикаты НЕОБХОДИМЫ!
	// Они используются для построения связей между материалами и продукцией в запросе отчета.
	// Отчёт строит таблицу КоличествоВыпуска из продукции и полуфабрикатов,
	// затем соединяет материалы с полуфабрикатами по ПартияВыходноеИзделие.
	// Без полуфабрикатов материалы "висят в воздухе" без связи с продукцией.
	// Поэтому оставляем ДобавлятьПолуфабрикатыВРезультат = Истина (как в оригинале)
	#КонецВставки
	
	// СтандартныеПодсистемы.ЗамерПроизводительности
	Замер = ОценкаПроизводительности.НачатьЗамерДлительнойОперации("ОбщийМодуль.СтруктураСебестоимости.ПостроитьДеревоСебестоимости");
	ПараметрыДерева.Вставить("КоличествоСтрок", 0);
	// Конец СтандартныеПодсистемы.ЗамерПроизводительности
	
	Если ПараметрыУзла = Неопределено Тогда
		ПараметрыУзла = СтруктураСебестоимости.ПараметрыУзлаДереваСебестоимости();
	КонецЕсли;
	#Вставка
	// ВАЖНО: Пакетная обработка несовместима с динамическим считыванием
	// Если включена пакетная обработка, автоматически отключаем динамическое считывание
	Если ПараметрыДерева.Свойство("ИспользоватьПакетнуюОбработку") 
		И ПараметрыДерева.ИспользоватьПакетнуюОбработку
		И ПараметрыДерева.ДинамическоеСчитывание Тогда
		
		ПараметрыДерева.ДинамическоеСчитывание = Ложь;
		
		ЗаписьЖурналаРегистрации(
			"СтруктураСебестоимости.ПакетнаяОбработка",
			УровеньЖурналаРегистрации.Информация,
			,
			,
			"Динамическое считывание автоматически отключено для использования пакетной обработки");
	КонецЕсли;
	#КонецВставки
	
	Если ПараметрыДерева.Результат = Неопределено Тогда
		ПустоеДеревоСебестоимости(ПараметрыДерева, ПараметрыУзла);
	КонецЕсли;

	ЗаполнитьДеревоСебестоимости(ПараметрыДерева, ПараметрыУзла);
	#Вставка
	// Вывод статистики по обнаруженным циклам
	Если ПараметрыДерева.Свойство("ОбнаруженныеЦиклы") 
		И ПараметрыДерева.ОбнаруженныеЦиклы.Количество() > 0 Тогда
		
		ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			"При построении дерева себестоимости обнаружено циклических зависимостей: %1",
			Строка(ПараметрыДерева.ОбнаруженныеЦиклы.Количество()));
		ЗаписьЖурналаРегистрации(
			"СтруктураСебестоимости.СтатистикаЦиклов",
			УровеньЖурналаРегистрации.Предупреждение,
			,
			,
			ТекстСообщения);
	КонецЕсли;
	#КонецВставки

	// СтандартныеПодсистемы.ЗамерПроизводительности
	ОценкаПроизводительности.ЗакончитьЗамерДлительнойОперации(Замер, ПараметрыДерева.КоличествоСтрок / 1000);
	// Конец СтандартныеПодсистемы.ЗамерПроизводительности

КонецПроцедуры

&ИзменениеИКонтроль("РазузловатьУзелДереваСебестоимости")
Процедура ikon_cost_РазузловатьУзелДереваСебестоимости(ПараметрыДерева, ПараметрыУзла, ТаблицаРезультата, ОписаниеПродукции)

	Если ПараметрыДерева.ТипРезультата = "ДеревоЗначений" Тогда
		Результат = ТаблицаРезультата.Строки;
		Если ПараметрыДерева.ДинамическоеСчитывание Тогда
			Результат.Очистить();
		КонецЕсли;
	Иначе
		Результат = ТаблицаРезультата
	КонецЕсли;

	ПройденныйПуть = Неопределено;
	Если НЕ ПараметрыДерева.Свойство("ПройденныйПуть", ПройденныйПуть) Тогда
		ПройденныйПуть = Новый ТаблицаЗначений;
		ПройденныйПуть.Колонки.Добавить("Партия");
		ПройденныйПуть.Колонки.Добавить("АналитикаУчетаПартий");
		ПройденныйПуть.Индексы.Добавить("Партия, АналитикаУчетаПартий");
		ПараметрыДерева.Вставить("ПройденныйПуть", ПройденныйПуть);
		#Вставка
		// Инициализируем параметры защиты от циклов и глубокой рекурсии
		ПараметрыДерева.Вставить("МаксимальнаяГлубинаРекурсии", 50);
		ПараметрыДерева.Вставить("ОбнаруженныеЦиклы", Новый Массив);
		#КонецВставки
	КонецЕсли;

	АналитикаУчетаПродукции			= ОписаниеПродукции.АналитикаУчетаПродукции;
	ПартияПродукции					= ОписаниеПродукции.ПартияПродукции;
	АналитикаУчетаПартийПродукции	= ОписаниеПродукции.АналитикаУчетаПартийПродукции;
	УровеньУзла						= ОписаниеПродукции.Уровень + 1;
	#Вставка
	// Проверка максимальной глубины рекурсии
	Если УровеньУзла > ПараметрыДерева.МаксимальнаяГлубинаРекурсии Тогда
		ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			"Достигнута максимальная глубина разузлования (%1 уровней). Партия: %2, Аналитика партий: %3",
			Строка(УровеньУзла),
			Строка(ПартияПродукции),
			Строка(АналитикаУчетаПартийПродукции));
		ЗаписьЖурналаРегистрации(
			"СтруктураСебестоимости.МаксимальнаяГлубинаРекурсии",
			УровеньЖурналаРегистрации.Предупреждение,
			,
			,
			ТекстСообщения);
		Возврат;
	КонецЕсли;
	#КонецВставки

	ВыводитьДопРасходы = ПараметрыУзла.Отборы.РазворачиватьДопРасходы И НЕ (УровеньУзла = 1);
	СебестоимостьУзла = СебестоимостьУзла(ПараметрыДерева, ПараметрыУзла, ВыводитьДопРасходы);

	// СтандартныеПодсистемы.ЗамерПроизводительности
	ПараметрыДерева.КоличествоСтрок = ПараметрыДерева.КоличествоСтрок + СебестоимостьУзла.Количество();
	// Конец СтандартныеПодсистемы.ЗамерПроизводительности

	ЭтоРазузлованиеДопРасходов = Ложь;
	Для Каждого ТекПартия Из СебестоимостьУзла Цикл

		Если ТекПартия.ТребуетсяРазузлование И ТекПартия.КоличествоЗатрата <> 0 Тогда
			ПараметрыОтбора = Новый Структура("Партия, АналитикаУчетаПартий",
			ТекПартия.ПартияЗатрата,
			ТекПартия.АналитикаУчетаПартийЗатрата);
			МассивСтрок = ПройденныйПуть.НайтиСтроки(ПараметрыОтбора);
			#Вставка
			// Логирование обнаруженного цикла
			Если МассивСтрок.Количество() > 0 Тогда
				ИнформацияОЦикле = Новый Структура;
				ИнформацияОЦикле.Вставить("Уровень", УровеньУзла);
				ИнформацияОЦикле.Вставить("ПартияЗатрата", ТекПартия.ПартияЗатрата);
				ИнформацияОЦикле.Вставить("АналитикаУчетаПартийЗатрата", ТекПартия.АналитикаУчетаПартийЗатрата);
				ИнформацияОЦикле.Вставить("Затрата", ТекПартия.Затрата);
				ИнформацияОЦикле.Вставить("ПартияПродукции", ПартияПродукции);
				ИнформацияОЦикле.Вставить("АналитикаУчетаПартийПродукции", АналитикаУчетаПартийПродукции);
				
				ПараметрыДерева.ОбнаруженныеЦиклы.Добавить(ИнформацияОЦикле);
				
				ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					"Обнаружен циклический переход на уровне %1: Затрата '%2' (Партия: %3, Аналитика партий: %4) -> уже обрабатывалась в пути от Партии: %5, Аналитики партий: %6",
					Строка(УровеньУзла),
					Строка(ТекПартия.Затрата),
					Строка(ТекПартия.ПартияЗатрата),
					Строка(ТекПартия.АналитикаУчетаПартийЗатрата),
					Строка(ПартияПродукции),
					Строка(АналитикаУчетаПартийПродукции));
				ЗаписьЖурналаРегистрации(
					"СтруктураСебестоимости.ОбнаруженЦикл",
					УровеньЖурналаРегистрации.Предупреждение,
					,
					,
					ТекстСообщения);
			КонецЕсли;
			#КонецВставки
		Иначе
			МассивСтрок = Новый Массив;
		КонецЕсли;

		Если ПараметрыДерева.ТипРезультата = "ДеревоЗначений"
			ИЛИ ПараметрыДерева.ДобавлятьПолуфабрикатыВРезультат
			ИЛИ Не ТекПартия.ТребуетсяРазузлование Тогда
			СтрокаПартия = Результат.Добавить(); // СтрокаДереваЗначений
			ЗаполнитьЗначенияСвойств(СтрокаПартия, ТекПартия);

			СтрокаПартия.Идентификатор	= Новый УникальныйИдентификатор();
			Если ТекПартия.ТребуетсяРазузлование
				И Окр(ТекПартия.КоличествоЗатрата, 3) <> 0
				И (ТекПартия.СуммаЗатрата <> 0 Или ТекПартия.СуммаЗатратаЗабалансовая <> 0)
				И МассивСтрок.Количество() = 0 Тогда

				СтрокаПартия.ВидСтроки		= Перечисления.ВидыСтрокДереваСебестоимости.ПартияПолуфабриката;
				СтрокаПартия.Числитель 		= ТекПартия.КоличествоЗатрата;

			Иначе
				СтрокаПартия.ВидСтроки		= Перечисления.ВидыСтрокДереваСебестоимости.ПартияЗатраты;
				СтрокаПартия.ТребуетсяРазузлование = Ложь;
			КонецЕсли;

			СтрокаПартия.АналитикаУчетаПродукции		= АналитикаУчетаПродукции;
			СтрокаПартия.ПартияПродукции				= ПартияПродукции;
			СтрокаПартия.АналитикаУчетаПартийПродукции	= АналитикаУчетаПартийПродукции;

			СтрокаПартия.Номенклатура			= ТекПартия.Затрата;
			СтрокаПартия.Характеристика			= ТекПартия.ХарактеристикаЗатрата;
			СтрокаПартия.Серия					= ТекПартия.СерияЗатрата;
			СтрокаПартия.Назначение				= ТекПартия.НазначениеЗатрата;
			СтрокаПартия.Партия					= ТекПартия.ПартияЗатрата;
			СтрокаПартия.АналитикаУчетаПартий	= ТекПартия.АналитикаУчетаПартийЗатрата;
			СтрокаПартия.ЕдиницаИзмерения		= ТекПартия.ЕдиницаИзмеренияЗатрата;
			СтрокаПартия.Уровень				= УровеньУзла;

			СтрокаПартия.Количество			= ТекПартия.КоличествоЗатрата;
			СтрокаПартия.Сумма				= Окр(ТекПартия.СуммаЗатрата, 2);
			СтрокаПартия.ДопРасходы			= Окр(СтрокаПартия.ДопРасходы, 2);
			СтрокаПартия.НалоговыйУчет		= Окр(СтрокаПартия.НалоговыйУчет, 2);
			СтрокаПартия.СуммаЗабалансовая	= ТекПартия.СуммаЗатратаЗабалансовая;

			// Уменьшаем суммовые показатели в узле на разузлованные суммы. 
			// На оставшиеся суммы будет сформирована отдельная строка для отражения расхождения стоимости с детализацией.
			Если ПараметрыУзла.Сумма <> 0 Или ПараметрыУзла.СуммаЗабалансовая <> 0 Тогда
				ПараметрыУзла.Сумма = ПараметрыУзла.Сумма - СтрокаПартия.Сумма;
				ПараметрыУзла.Материальные = ПараметрыУзла.Материальные - СтрокаПартия.Материальные;
				ПараметрыУзла.ДопРасходы = ПараметрыУзла.ДопРасходы - СтрокаПартия.ДопРасходы;
				ПараметрыУзла.Трудозатраты = ПараметрыУзла.Трудозатраты - СтрокаПартия.Трудозатраты;
				ПараметрыУзла.ПостатейныеПеременные = ПараметрыУзла.ПостатейныеПеременные - СтрокаПартия.ПостатейныеПеременные;
				ПараметрыУзла.ПостатейныеПостоянные = ПараметрыУзла.ПостатейныеПостоянные - СтрокаПартия.ПостатейныеПостоянные;
				ПараметрыУзла.НалоговыйУчет = ПараметрыУзла.НалоговыйУчет - СтрокаПартия.НалоговыйУчет;
				ПараметрыУзла.ПостояннаяРазница = ПараметрыУзла.ПостояннаяРазница - СтрокаПартия.ПостояннаяРазница;
				ПараметрыУзла.ВременнаяРазница = ПараметрыУзла.ВременнаяРазница - СтрокаПартия.ВременнаяРазница;
				ПараметрыУзла.СуммаЗабалансовая = ПараметрыУзла.СуммаЗабалансовая - СтрокаПартия.СуммаЗабалансовая;

				ЭтоРазузлованиеДопРасходов = (ТекПартия.ТипЗатрат = "ДопРасходы");
			КонецЕсли;
		КонецЕсли;

		Если ТекПартия.ТребуетсяРазузлование
			И ПараметрыДерева.ТипРезультата = "ДеревоЗначений"
			И ПараметрыДерева.ДинамическоеСчитывание Тогда
			СтрокаПартия.Строки.Добавить();
		ИначеЕсли ТекПартия.ТребуетсяРазузлование
			И Окр(ТекПартия.КоличествоЗатрата, 3) <> 0
			И (ТекПартия.СуммаЗатрата <> 0 Или ТекПартия.СуммаЗатратаЗабалансовая <> 0)
			И МассивСтрок.Количество() = 0
			ИЛИ ТекПартия.ТребуетсяРазузлованиеДопРасходов
			И Окр(ТекПартия.КоличествоЗатрата, 3) <> 0
			И ТекПартия.ДопРасходы <> 0 Тогда
			// общий подход к заполнению отбора параметров узла и условиям разузлования должен совпадать с:
			// - ЗаполнитьДеревоСебестоимости();
			// - Отчет.ДеревоСебестоимости.МодульОбъекта.ПолноеДеревоСебестоимостиПередРазворачиваниемСервер(). 
			ПараметрыУзлаПартии = СтруктураСебестоимости.ПараметрыУзлаДереваСебестоимости();

			Если НЕ ТекПартия.ТребуетсяРазузлованиеДопРасходов Тогда
				НовыйПуть = ПройденныйПуть.Добавить();
				НовыйПуть.Партия = ТекПартия.ПартияЗатрата;
				НовыйПуть.АналитикаУчетаПартий = ТекПартия.АналитикаУчетаПартийЗатрата;
			КонецЕсли;

			Отборы = ПараметрыУзлаПартии.Отборы;
			Отборы.ДанныеПоСебестоимости = ПараметрыУзла.Отборы.ДанныеПоСебестоимости;
			Отборы.Продукция.Добавить(ТекПартия.Затрата);
			Отборы.ХарактеристикиПродукции.Добавить(ТекПартия.ХарактеристикаЗатрата);
			Отборы.СерииПродукции.Добавить(ТекПартия.СерияЗатрата);
			// При разузловании полуфабрикатов отбор по назначению не нужен, т.к. полуфабрикат может быть выпущен без назначения или
			// с указанием другого назначения.
			Отборы.ПартииПродукции.Добавить(ТекПартия.ПартияЗатрата);
			Отборы.АналитикиУчетаПартийПродукции.Добавить(ТекПартия.АналитикаУчетаПартийЗатрата);
			Отборы.АналитикаУчетаЗатрата.Добавить(ТекПартия.АналитикаУчетаЗатрата);
			// для знаменателя и количества продукции берем модуль значения, чтобы знак количества и сумм затрат определялся по числителю, который при выпуске будет > 0, а при сторно < 0
			Отборы.Числитель               = ТекПартия.КоличествоЗатрата;
			Отборы.КоличествоПродукции     = Макс(-ТекПартия.КоличествоЗатрата, ТекПартия.КоличествоЗатрата);
			Отборы.РазворачиватьДопРасходы = ПараметрыУзла.Отборы.РазворачиватьДопРасходы;
			Отборы.ДатаИсходнойПартии      = ПараметрыУзла.Отборы.ДатаИсходнойПартии;
			Отборы.ДатаОкончания           = ПараметрыУзла.Отборы.ДатаОкончания;

			Отборы.ВключитьНДСВСтоимость   = ТекПартия.ВключитьНДСВСтоимость;
			Отборы.ИсключитьНДСИзСтоимости = ТекПартия.ИсключитьНДСИзСтоимости;
			Отборы.АналитикаУчетаВыходноеИзделие = ТекПартия.АналитикаУчетаЗатрата;
			Отборы.СтатьяКалькуляции       = ТекПартия.СтатьяКалькуляции;

			Если ПараметрыДерева.ТипРезультата = "ДеревоЗначений" Тогда
				ТаблицаРезультатаПартии = СтрокаПартия;
			Иначе
				ТаблицаРезультатаПартии = Результат;
			КонецЕсли;

			Если НЕ ТекПартия.ТребуетсяРазузлованиеДопРасходов Тогда
				ПараметрыУзлаПартии.Сумма = СтрокаПартия.Сумма;
				ПараметрыУзлаПартии.Материальные = СтрокаПартия.Материальные;
				ПараметрыУзлаПартии.ДопРасходы = СтрокаПартия.ДопРасходы;
				ПараметрыУзлаПартии.Трудозатраты = СтрокаПартия.Трудозатраты;
				ПараметрыУзлаПартии.ПостатейныеПеременные = СтрокаПартия.ПостатейныеПеременные;
				ПараметрыУзлаПартии.ПостатейныеПостоянные = СтрокаПартия.ПостатейныеПостоянные;
				ПараметрыУзлаПартии.НалоговыйУчет = СтрокаПартия.НалоговыйУчет;
				ПараметрыУзлаПартии.ПостояннаяРазница = СтрокаПартия.ПостояннаяРазница;
				ПараметрыУзлаПартии.ВременнаяРазница = СтрокаПартия.ВременнаяРазница;
				ПараметрыУзлаПартии.СуммаЗабалансовая = СтрокаПартия.СуммаЗабалансовая;
			КонецЕсли;

			ОписаниеПродукции.Вставить("Уровень", УровеньУзла);
			Если ПараметрыДерева.ТипРезультата = "МенеджерВременныхТаблиц" Тогда
				КоличествоСтрокРезультата = ТаблицаРезультатаПартии.Количество();
			КонецЕсли;
			РазузловатьУзелДереваСебестоимости(ПараметрыДерева, ПараметрыУзлаПартии, ТаблицаРезультатаПартии, ОписаниеПродукции);

			// Если разозлование доп расходов не выполнено, снимем признак ТребуетсяРазузлованиеДопРасходов.
			Если ПараметрыДерева.ТипРезультата = "МенеджерВременныхТаблиц"
				И ТекПартия.ТребуетсяРазузлованиеДопРасходов
				И КоличествоСтрокРезультата = ТаблицаРезультатаПартии.Количество() Тогда
				СтрокаПартия.ТребуетсяРазузлованиеДопРасходов = Ложь;
			КонецЕсли;
		КонецЕсли;

		#Вставка
		// УБРАНА логика удаления из ПройденныйПуть для предотвращения встречных циклов.
		// Партии остаются в ПройденныйПуть на протяжении всего процесса построения дерева,
		// что обеспечивает корректное обнаружение циклических зависимостей любой сложности.
		#КонецВставки
		#Удаление
		// Удалим строку, по которой уже выполнено разузлование.
		Если ТекПартия.ТребуетсяРазузлование
			И Окр(ТекПартия.КоличествоЗатрата, 3) <> 0
			И ТекПартия.СуммаЗатрата <> 0 Тогда
			ПараметрыОтбора = Новый Структура("Партия, АналитикаУчетаПартий",
			ТекПартия.ПартияЗатрата,
			ТекПартия.АналитикаУчетаПартийЗатрата);
			МассивСтрок = ПройденныйПуть.НайтиСтроки(ПараметрыОтбора);
			Для Каждого СтрокаКУдалению Из МассивСтрок Цикл
				ПройденныйПуть.Удалить(СтрокаКУдалению);
			КонецЦикла;
		КонецЕсли;
		#КонецУдаления

	КонецЦикла;

	// При наличии данных о разузловании добавим строку на суммы изменения стоимости.
	Если СебестоимостьУзла.Количество() > 0 И НЕ ЭтоРазузлованиеДопРасходов Тогда
		УчестьИзменениеСтоимости(ПараметрыУзла, ОписаниеПродукции, Результат);
	КонецЕсли;

КонецПроцедуры

&ИзменениеИКонтроль("ЗаполнитьДеревоСебестоимости")
Процедура ikon_cost_ЗаполнитьДеревоСебестоимости(ПараметрыДерева, ПараметрыУзла)

	Запрос = ЗапросВыпущеннаяПродукция(ПараметрыУзла, Ложь);
	ВыпущеннаяПродукция = Запрос.Выполнить().Выгрузить();
	#Вставка
	// ДИАГНОСТИКА
	ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		"ЗаполнитьДеревоСебестоимости: получено строк ВыпущеннаяПродукция=%1, ДинамическоеСчитывание=%2, ИспользоватьПакетнуюОбработку=%3",
		Строка(ВыпущеннаяПродукция.Количество()),
		Строка(ПараметрыДерева.ДинамическоеСчитывание),
		Строка(ПараметрыДерева.Свойство("ИспользоватьПакетнуюОбработку") И ПараметрыДерева.ИспользоватьПакетнуюОбработку));
	ЗаписьЖурналаРегистрации(
		"СтруктураСебестоимости.Диагностика",
		УровеньЖурналаРегистрации.Информация,
		,
		,
		ТекстСообщения);
	#КонецВставки

	Если ПараметрыДерева.ТипРезультата = "ДеревоЗначений" Тогда
		Результат = ПараметрыДерева.Результат.Строки;
	ИначеЕсли ПараметрыДерева.ТипРезультата = "ТаблицаЗначений" Тогда
		Результат = ПараметрыДерева.Результат;
	Иначе
		Результат = Новый ТаблицаЗначений;
		ИнициализироватьПоляДереваСебестоимости(Результат);
		ПоляТаблицы = РасчетСебестоимостиПрикладныеАлгоритмы.ПолучитьИменаКолонокСтрокой(Результат, "Идентификатор");
		СчетчикТаблиц = 0;
		ИменаТаблиц = "";
	КонецЕсли;

	// СтандартныеПодсистемы.ЗамерПроизводительности
	ПараметрыДерева.КоличествоСтрок = ПараметрыДерева.КоличествоСтрок + ВыпущеннаяПродукция.Количество();
	// Конец СтандартныеПодсистемы.ЗамерПроизводительности

	Для Каждого ТекПартия Из ВыпущеннаяПродукция Цикл
		
		#Удаление
		Если ПараметрыДерева.ТипРезультата = "ДеревоЗначений"
			ИЛИ ПараметрыДерева.ДобавлятьПолуфабрикатыВРезультат
			ИЛИ Не ТекПартия.ТребуетсяРазузлование Тогда
		#КонецУдаления
		#Вставка
		// КРИТИЧНО: Строка ПРОДУКЦИИ (уровень 0) всегда должна добавляться в результат!
		// ДобавлятьПолуфабрикатыВРезультат управляет только полуфабрикатами (уровни 1+)
		// Для МенеджерВременныхТаблиц строка продукции нужна для корректного формирования отчета
		Если Истина Тогда
		#КонецВставки
			СтрокаПартия = Результат.Добавить(); // СтрокаДереваЗначений
			ЗаполнитьЗначенияСвойств(СтрокаПартия, ТекПартия);
			
			СтрокаПартия.Идентификатор	= Новый УникальныйИдентификатор();
			СтрокаПартия.ВидСтроки		= Перечисления.ВидыСтрокДереваСебестоимости.ПартияПродукции;
			
			СтрокаПартия.АналитикаУчетаВыходноеИзделие			= ТекПартия.АналитикаУчетаПродукции;
			СтрокаПартия.АналитикаУчетаПартийВыходноеИзделие	= ТекПартия.АналитикаУчетаПартийПродукции;
			СтрокаПартия.ПартияВыходноеИзделие					= ТекПартия.ПартияПродукции;
			
			СтрокаПартия.Номенклатура			= ТекПартия.Продукция;
			СтрокаПартия.Характеристика			= ТекПартия.ХарактеристикаПродукции;
			СтрокаПартия.Серия					= ТекПартия.СерияПродукции;
			СтрокаПартия.Назначение				= ТекПартия.НазначениеПродукции;
			СтрокаПартия.Валюта					= ТекПартия.Валюта;
			СтрокаПартия.Партия					= ТекПартия.ПартияПродукции;
			СтрокаПартия.АналитикаУчетаПартий	= ТекПартия.АналитикаУчетаПартийПродукции;
			СтрокаПартия.ЕдиницаИзмерения		= ТекПартия.ЕдиницаИзмеренияПродукция;
			
			СтрокаПартия.Количество	= ТекПартия.КоличествоПродукция;
			СтрокаПартия.Сумма		= ТекПартия.СуммаПродукция;
			СтрокаПартия.СуммаЗабалансовая = ТекПартия.СуммаПродукцияЗабалансовая;
		КонецЕсли;
		
		Если ТекПартия.ТребуетсяРазузлование
			И ПараметрыДерева.ТипРезультата = "ДеревоЗначений"
			И ПараметрыДерева.ДинамическоеСчитывание
			И ТекПартия.КоличествоПродукция <> 0 Тогда

			СтрокаПартия.Строки.Добавить();

		ИначеЕсли ТекПартия.ТребуетсяРазузлование
			И ТекПартия.КоличествоПродукция <> 0 Тогда //проверка на отсторнированный выпуск в выбранном периоде
			// общий подход к заполнению отбора параметров узла и условиям разузлования должен совпадать с:
			// - РазузловатьУзелДереваСебестоимости();
			// - Отчет.ДеревоСебестоимости.МодульОбъекта.ПолноеДеревоСебестоимостиПередРазворачиваниемСервер(). 
			ПараметрыУзлаПартии = СтруктураСебестоимости.ПараметрыУзлаДереваСебестоимости();

			Отборы = ПараметрыУзлаПартии.Отборы;
			Отборы.ДанныеПоСебестоимости = ПараметрыУзла.Отборы.ДанныеПоСебестоимости;
			Отборы.Продукция.Добавить(ТекПартия.Продукция);
			Отборы.ХарактеристикиПродукции.Добавить(ТекПартия.ХарактеристикаПродукции);
			Отборы.СерииПродукции.Добавить(ТекПартия.СерияПродукции);
			Отборы.НазначенияПродукции.Добавить(ТекПартия.НазначениеПродукции);
			Отборы.ПартииПродукции.Добавить(ТекПартия.ПартияПродукции);
			Отборы.АналитикиУчетаПартийПродукции.Добавить(ТекПартия.АналитикаУчетаПартийПродукции);
			// для знаменателя и количества продукции берем модуль значения, чтобы знак количества и сумм затрат определялся по числителю, который при выпуске будет > 0, а при сторно < 0
			Отборы.Числитель               = ТекПартия.Числитель;
			Отборы.Знаменатель             = Макс(-ТекПартия.Знаменатель, ТекПартия.Знаменатель);
			Отборы.КоличествоПродукции     = Макс(-ТекПартия.КоличествоПродукция,ТекПартия. КоличествоПродукция);
			Отборы.РазворачиватьДопРасходы = ПараметрыУзла.Отборы.РазворачиватьДопРасходы;
			Отборы.ДатаИсходнойПартии = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(ТекПартия.ПартияПродукции, "Дата");
			Отборы.ДатаОкончания           = ПараметрыУзла.Отборы.ДатаОкончания;

			ПараметрыУзлаПартии.Сумма = ТекПартия.СуммаПродукция;
			ПараметрыУзлаПартии.Материальные = ТекПартия.Материальные;
			ПараметрыУзлаПартии.ДопРасходы = ТекПартия.ДопРасходы;
			ПараметрыУзлаПартии.Трудозатраты = ТекПартия.Трудозатраты;
			ПараметрыУзлаПартии.ПостатейныеПеременные = ТекПартия.ПостатейныеПеременные;
			ПараметрыУзлаПартии.ПостатейныеПостоянные = ТекПартия.ПостатейныеПостоянные;
			ПараметрыУзлаПартии.НалоговыйУчет = ТекПартия.НалоговыйУчет;
			ПараметрыУзлаПартии.ПостояннаяРазница = ТекПартия.ПостояннаяРазница;
			ПараметрыУзлаПартии.ВременнаяРазница = ТекПартия.ВременнаяРазница;
			ПараметрыУзлаПартии.СуммаЗабалансовая = ТекПартия.СуммаПродукцияЗабалансовая;

			ОписаниеПродукции = Новый Структура("АналитикаУчетаПродукции, ПартияПродукции, АналитикаУчетаПартийПродукции");
			ЗаполнитьЗначенияСвойств(ОписаниеПродукции, ТекПартия);
			ОписаниеПродукции.Вставить("Уровень", 0);

			Если ПараметрыДерева.ТипРезультата = "ДеревоЗначений" Тогда
				ТаблицаРезультата = СтрокаПартия;
			Иначе
				ТаблицаРезультата = Результат;
			КонецЕсли;

			#Удаление
			РазузловатьУзелДереваСебестоимости(ПараметрыДерева, ПараметрыУзлаПартии, ТаблицаРезультата, ОписаниеПродукции);
			#КонецУдаления
			#Вставка
			// Выбор между пакетной обработкой и рекурсивной
			Если ПараметрыДерева.Свойство("ИспользоватьПакетнуюОбработку") 
				И ПараметрыДерева.ИспользоватьПакетнуюОбработку 
				И НЕ ПараметрыДерева.ДинамическоеСчитывание Тогда
				
				// Пакетная обработка: формируем узел для добавления в очередь
				Узел = Новый Структура;
				Узел.Вставить("ПараметрыУзла", ПараметрыУзлаПартии);
				Узел.Вставить("ТаблицаРезультата", ТаблицаРезультата);
				Узел.Вставить("ОписаниеПродукции", ОписаниеПродукции);
				Узел.Вставить("СтрокаПартия", СтрокаПартия);
				
				Если НЕ ПараметрыДерева.Свойство("УзлыДляПакетнойОбработки") Тогда
					ПараметрыДерева.Вставить("УзлыДляПакетнойОбработки", Новый Массив);
				КонецЕсли;
				
				ПараметрыДерева.УзлыДляПакетнойОбработки.Добавить(Узел);
				// ДИАГНОСТИКА
				ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					"Узел добавлен в пакет для обработки. Всего узлов в пакете: %1",
					Строка(ПараметрыДерева.УзлыДляПакетнойОбработки.Количество()));
				ЗаписьЖурналаРегистрации(
					"СтруктураСебестоимости.Диагностика",
					УровеньЖурналаРегистрации.Информация,
					,
					,
					ТекстСообщения);
			Иначе
				// Старая рекурсивная обработка (сохранена для обратной совместимости)
				РазузловатьУзелДереваСебестоимости(ПараметрыДерева, ПараметрыУзлаПартии, ТаблицаРезультата, ОписаниеПродукции);
			КонецЕсли;
			#КонецВставки

		КонецЕсли;

		#Удаление
		Если ПараметрыДерева.ТипРезультата = "МенеджерВременныхТаблиц" Тогда
			СчетчикТаблиц = СчетчикТаблиц + 1;
			ИмяТекущейТаблицы = "Результат" + Формат(СчетчикТаблиц, "ЧГ=0;");
			РасчетСебестоимостиПрикладныеАлгоритмы.ПоместитьТаблицуЗначенийВоВременнуюТаблицу(
			ПараметрыДерева.Результат,
			ИмяТекущейТаблицы,
			Результат,
			ПоляТаблицы);
			ИменаТаблиц = ИменаТаблиц + ?(ПустаяСтрока(ИменаТаблиц), "", ",") + ИмяТекущейТаблицы;
			Результат.Очистить();
		КонецЕсли;
		#КонецУдаления
		#Вставка
		// ВАЖНО: При пакетной обработке НЕ сохраняем и НЕ очищаем Результат в цикле!
		// Узлы используют ссылку на эту таблицу, и она будет сохранена после пакетной обработки.
		ИспользуетсяПакетнаяОбработка = ПараметрыДерева.Свойство("ИспользоватьПакетнуюОбработку") 
			И ПараметрыДерева.ИспользоватьПакетнуюОбработку 
			И НЕ ПараметрыДерева.ДинамическоеСчитывание;
		
		Если ПараметрыДерева.ТипРезультата = "МенеджерВременныхТаблиц" 
			И НЕ ИспользуетсяПакетнаяОбработка Тогда
			
			СчетчикТаблиц = СчетчикТаблиц + 1;
			ИмяТекущейТаблицы = "Результат" + Формат(СчетчикТаблиц, "ЧГ=0;");
			
			// ДИАГНОСТИКА: сохранение в цикле
			ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				" СТАРЫЙ: создание ВТ '%1' в цикле, строк=%2",
				ИмяТекущейТаблицы,
				Строка(Результат.Количество()));
			ЗаписьЖурналаРегистрации(
				"СтруктураСебестоимости.Диагностика",
				УровеньЖурналаРегистрации.Информация,
				,
				,
				ТекстСообщения);
			
			РасчетСебестоимостиПрикладныеАлгоритмы.ПоместитьТаблицуЗначенийВоВременнуюТаблицу(
				ПараметрыДерева.Результат,
				ИмяТекущейТаблицы,
				Результат,
				ПоляТаблицы);
			ИменаТаблиц = ИменаТаблиц + ?(ПустаяСтрока(ИменаТаблиц), "", ",") + ИмяТекущейТаблицы;
			Результат.Очистить();
		КонецЕсли;
		#КонецВставки

	КонецЦикла;

	#Удаление
	Если ПараметрыДерева.ТипРезультата = "МенеджерВременныхТаблиц" Тогда
		Если НЕ ПустаяСтрока(ИменаТаблиц) Тогда
			РасчетСебестоимостиПрикладныеАлгоритмы.ОбъединитьВременныеТаблицы(
			ПараметрыДерева.Результат,
			ИменаТаблиц,
			"Результат",
			ПоляТаблицы, "", , Истина);
		Иначе
			Запрос = Новый Запрос;
			Запрос.МенеджерВременныхТаблиц = ПараметрыДерева.Результат;
			Запрос.Текст =
			"ВЫБРАТЬ
			|	*
			|ПОМЕСТИТЬ Результат
			|ИЗ
			|	&Результат КАК Результат";

			Результат.Колонки.Удалить("Идентификатор");
			Запрос.УстановитьПараметр("Результат", Результат);
			// Структуру ВТ Результат см. в СтруктураСебестоимости.СтруктураПолейДереваСебестоимости.
			Запрос.Выполнить();
		КонецЕсли;
	КонецЕсли;
	#КонецУдаления
	#Вставка
	// Обработка накопленных узлов для пакетной обработки (оптимизация N+1)
	// ВАЖНО: Обработка пакета ПО УРОВНЯМ с сохранением после каждого уровня!
	Если ПараметрыДерева.Свойство("УзлыДляПакетнойОбработки") 
		И ПараметрыДерева.УзлыДляПакетнойОбработки.Количество() > 0 Тогда
		
		УзлыТекущегоУровня = ПараметрыДерева.УзлыДляПакетнойОбработки;
		НомерУровня = 1;
		
		// Обрабатываем уровни по очереди (НЕ очищаем Результат - накапливаем в нём!)
		Пока УзлыТекущегоУровня.Количество() > 0 Цикл
			
			ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				" НОВЫЙ (ПАКЕТНЫЙ): начало обработки уровня %1, узлов=%2, накоплено строк=%3",
				Строка(НомерУровня),
				Строка(УзлыТекущегоУровня.Количество()),
				Строка(Результат.Количество()));
			ЗаписьЖурналаРегистрации(
				"СтруктураСебестоимости.Диагностика",
				УровеньЖурналаРегистрации.Информация,
				,
				,
				ТекстСообщения);
			
			// Обработать текущий уровень
			УзлыСледующегоУровня = РазузловатьУзлыПакетом(ПараметрыДерева, УзлыТекущегоУровня);
			
			// Переход к следующему уровню
			УзлыТекущегоУровня = УзлыСледующегоУровня;
			НомерУровня = НомерУровня + 1;
			
		КонецЦикла;
		
		// ФИЛЬТРАЦИЯ и СОХРАНЕНИЕ (один раз в конце!)
		Если ПараметрыДерева.ТипРезультата = "МенеджерВременныхТаблиц" 
			И Результат.Количество() > 0 Тогда
			
			// ФИЛЬТРАЦИЯ: удаляем строки "Усреднение стоимости" и "Изменение стоимости при хранении"
			КоличествоДоФильтрации = Результат.Количество();
			Индекс = Результат.Количество() - 1;
			Пока Индекс >= 0 Цикл
				СтрокаРезультата = Результат[Индекс];
				Если СтрокаРезультата.Номенклатура = "Усреднение стоимости в незавершенном производстве"
					ИЛИ СтрокаРезультата.Номенклатура = "Изменение стоимости при хранении" Тогда
					Результат.Удалить(Индекс);
				КонецЕсли;
				Индекс = Индекс - 1;
			КонецЦикла;
			
			КоличествоУдаленных = КоличествоДоФильтрации - Результат.Количество();
			
			// Сохраняем одной таблицей
			СчетчикТаблиц = СчетчикТаблиц + 1;
			ИмяТекущейТаблицы = "Результат" + Формат(СчетчикТаблиц, "ЧГ=0;");
			
			РасчетСебестоимостиПрикладныеАлгоритмы.ПоместитьТаблицуЗначенийВоВременнуюТаблицу(
				ПараметрыДерева.Результат,
				ИмяТекущейТаблицы,
				Результат,
				ПоляТаблицы);
			ИменаТаблиц = ИменаТаблиц + ?(ПустаяСтрока(ИменаТаблиц), "", ",") + ИмяТекущейТаблицы;
			
			// КРИТИЧНО: Очищаем таблицу после сохранения, чтобы избежать дублирования
			// Данные уже сохранены во временную таблицу, и не должны сохраняться повторно
			Результат.Очистить();
		КонецЕсли;
		
		ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			"Использована пакетная обработка: обработано узлов в первом уровне: %1, всего уровней: %2",
			Строка(ПараметрыДерева.УзлыДляПакетнойОбработки.Количество()),
			Строка(НомерУровня - 1));
		ЗаписьЖурналаРегистрации(
			"СтруктураСебестоимости.ПакетнаяОбработка",
			УровеньЖурналаРегистрации.Информация,
			,
			,
			ТекстСообщения);
	КонецЕсли;
	
	// ПРИМЕЧАНИЕ: При пакетной обработке данные сохраняются ПОСЛЕ КАЖДОГО УРОВНЯ (выше в цикле)
	// Этот блок нужен только для старого рекурсивного алгоритма или если остались несохраненные данные
	Если ПараметрыДерева.ТипРезультата = "МенеджерВременныхТаблиц" Тогда
		
		// Сохраняем оставшиеся данные (если есть)
		Если Результат.Количество() > 0 Тогда
			СчетчикТаблиц = СчетчикТаблиц + 1;
			ИмяТекущейТаблицы = "Результат" + Формат(СчетчикТаблиц, "ЧГ=0;");
			РасчетСебестоимостиПрикладныеАлгоритмы.ПоместитьТаблицуЗначенийВоВременнуюТаблицу(
				ПараметрыДерева.Результат,
				ИмяТекущейТаблицы,
				Результат,
				ПоляТаблицы);
			ИменаТаблиц = ИменаТаблиц + ?(ПустаяСтрока(ИменаТаблиц), "", ",") + ИмяТекущейТаблицы;
			
			ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				" Сохранены ОСТАВШИЕСЯ данные во ВТ '%1': строк=%2",
				ИмяТекущейТаблицы,
				Строка(Результат.Количество()));
			ЗаписьЖурналаРегистрации(
				"СтруктураСебестоимости.Диагностика",
				УровеньЖурналаРегистрации.Информация,
				,
				,
				ТекстСообщения);
		КонецЕсли;
		
			// Объединяем все временные таблицы в итоговую
		Если НЕ ПустаяСтрока(ИменаТаблиц) Тогда
			РасчетСебестоимостиПрикладныеАлгоритмы.ОбъединитьВременныеТаблицы(
			ПараметрыДерева.Результат,
			ИменаТаблиц,
			"Результат",
			ПоляТаблицы, "", , Истина);
		Иначе
			// Если вообще нет данных, создаем пустую временную таблицу
			Запрос = Новый Запрос;
			Запрос.МенеджерВременныхТаблиц = ПараметрыДерева.Результат;
			Запрос.Текст =
			"ВЫБРАТЬ
			|	*
			|ПОМЕСТИТЬ Результат
			|ИЗ
			|	&Результат КАК Результат";
			
			Результат.Колонки.Удалить("Идентификатор");
			Запрос.УстановитьПараметр("Результат", Результат);
			// Структуру ВТ Результат см. в СтруктураСебестоимости.СтруктураПолейДереваСебестоимости.
			Запрос.Выполнить();
		КонецЕсли;
	КонецЕсли;
	
	// ДИАГНОСТИКА: итоговый результат
	Если ПараметрыДерева.ТипРезультата = "ДеревоЗначений" Тогда
		КоличествоСтрокИтого = ПараметрыДерева.Результат.Строки.Количество();
	ИначеЕсли ПараметрыДерева.ТипРезультата = "ТаблицаЗначений" Тогда
		КоличествоСтрокИтого = ПараметрыДерева.Результат.Количество();
	Иначе
		// Для МенеджерВременныхТаблиц выполняем запрос подсчета строк
		Попытка
			Запрос = Новый Запрос;
			Запрос.МенеджерВременныхТаблиц = ПараметрыДерева.Результат;
			Запрос.Текст = 
			"ВЫБРАТЬ
			|	КОЛИЧЕСТВО(РАЗЛИЧНЫЕ Партия) КАК КоличествоУровень0
			|ИЗ
			|	Результат
			|ГДЕ
			|	Уровень = 0";
			РезультатПодсчета = Запрос.Выполнить().Выгрузить();
			КоличествоСтрокИтого = РезультатПодсчета[0].КоличествоУровень0;
		Исключение
			// Если временная таблица не существует или произошла ошибка
			КоличествоСтрокИтого = 0;
		КонецПопытки;
	КонецЕсли;
	
	ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		"ЗаполнитьДеревоСебестоимости: ИТОГОВЫЙ результат содержит строк верхнего уровня=%1",
		Строка(КоличествоСтрокИтого));
	ЗаписьЖурналаРегистрации(
		"СтруктураСебестоимости.Диагностика",
		УровеньЖурналаРегистрации.Информация,
		,
		,
		ТекстСообщения);
	#КонецВставки

КонецПроцедуры   

// Разузлование дерева себестоимости с пакетной обработкой по уровням (оптимизация N+1)
//
// Параметры:
//  ПараметрыДерева - см. СтруктураСебестоимости.ПараметрыДереваСебестоимости
//  УзлыДляОбработки - Массив из Структура - Массив узлов для обработки:
//    * ПараметрыУзла - Структура - Параметры узла
//    * ТаблицаРезультата - ДеревоЗначений, ТаблицаЗначений - Куда помещать результат
//    * ОписаниеПродукции - Структура - Описание продукции
//    * СтрокаПартия - СтрокаДереваЗначений - Ссылка на строку в дереве
//
Функция РазузловатьУзлыПакетом(ПараметрыДерева, УзлыДляОбработки)
	
	// ДИАГНОСТИКА
	ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		"РазузловатьУзлыПакетом: начало обработки, узлов=%1",
		Строка(УзлыДляОбработки.Количество()));
	ЗаписьЖурналаРегистрации(
		"СтруктураСебестоимости.Диагностика",
		УровеньЖурналаРегистрации.Информация,
		,
		,
		ТекстСообщения);
		
	Если УзлыДляОбработки.Количество() = 0 Тогда
		Возврат Новый Массив; // Возвращаем пустой массив, если нет узлов
	КонецЕсли;
	
	// Инициализация структур для отслеживания циклов
	ПройденныйПуть = Неопределено;
	Если НЕ ПараметрыДерева.Свойство("ПройденныйПуть", ПройденныйПуть) Тогда
		ПройденныйПуть = Новый ТаблицаЗначений;
		ПройденныйПуть.Колонки.Добавить("Партия");
		ПройденныйПуть.Колонки.Добавить("АналитикаУчетаПартий");
		ПройденныйПуть.Индексы.Добавить("Партия, АналитикаУчетаПартий");
		ПараметрыДерева.Вставить("ПройденныйПуть", ПройденныйПуть);
		// Инициализируем параметры защиты от циклов и глубокой рекурсии
		ПараметрыДерева.Вставить("МаксимальнаяГлубинаРекурсии", 50);
		ПараметрыДерева.Вставить("ОбнаруженныеЦиклы", Новый Массив);
	КонецЕсли;
	
	// Обрабатываем результаты для каждого узла
	УзлыСледующегоУровня = Новый Массив;
	
	// Обработка каждого узла с отдельным запросом
	// (текущая версия - без объединения запросов, но с обработкой по уровням)
	Для Каждого Узел Из УзлыДляОбработки Цикл
		
		// Определяем, нужно ли выводить дополнительные расходы
		УровеньУзла = Узел.ОписаниеПродукции.Уровень + 1;
		
		// Проверка максимальной глубины рекурсии
		Если УровеньУзла > ПараметрыДерева.МаксимальнаяГлубинаРекурсии Тогда
			ПартияПродукции = Узел.ОписаниеПродукции.ПартияПродукции;
			АналитикаУчетаПартийПродукции = Узел.ОписаниеПродукции.АналитикаУчетаПартийПродукции;
			
			ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				"Достигнута максимальная глубина разузлования (%1 уровней). Партия: %2, Аналитика партий: %3",
				Строка(УровеньУзла),
				Строка(ПартияПродукции),
				Строка(АналитикаУчетаПартийПродукции));
			ЗаписьЖурналаРегистрации(
				"СтруктураСебестоимости.МаксимальнаяГлубинаРекурсии",
				УровеньЖурналаРегистрации.Предупреждение,
				,
				,
				ТекстСообщения);
			Продолжить;
		КонецЕсли;
		
		ВыводитьДопРасходы = Узел.ПараметрыУзла.Отборы.РазворачиватьДопРасходы 
			И НЕ (Узел.ОписаниеПродукции.Уровень = 0);
		
		// Получаем данные для текущего узла отдельным запросом
		СебестоимостьУзла = СебестоимостьУзла(ПараметрыДерева, Узел.ПараметрыУзла, ВыводитьДопРасходы);
			
		// СтандартныеПодсистемы.ЗамерПроизводительности
		ПараметрыДерева.КоличествоСтрок = ПараметрыДерева.КоличествоСтрок + СебестоимостьУзла.Количество();
		// Конец СтандартныеПодсистемы.ЗамерПроизводительности
		
		// Обрабатываем каждую партию в результатах
		ОбработатьРезультатыУзла(ПараметрыДерева, Узел, СебестоимостьУзла, ПройденныйПуть, УзлыСледующегоУровня);
	КонецЦикла;
	
	// НЕ вызываем рекурсивно! Возвращаем узлы следующего уровня для обработки в цикле
	Возврат УзлыСледующегоУровня;
	
КонецФункции

// Обрабатывает результаты запроса для одного узла
Процедура ОбработатьРезультатыУзла(ПараметрыДерева, Узел, СебестоимостьУзла, ПройденныйПуть, УзлыСледующегоУровня)
	
	ПараметрыУзла = Узел.ПараметрыУзла;
	ТаблицаРезультата = Узел.ТаблицаРезультата;
	ОписаниеПродукции = Узел.ОписаниеПродукции;
	
	Если ПараметрыДерева.ТипРезультата = "ДеревоЗначений" Тогда
		Результат = ТаблицаРезультата.Строки;
	Иначе
		Результат = ТаблицаРезультата;
	КонецЕсли;
	
	// ДИАГНОСТИКА
	КоличествоДо = Результат.Количество();
	
	// ДИАГНОСТИКА: параметры обработки
	ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		"ОбработатьРезультатыУзла начало: ТипРезультата='%1', ДобавлятьПолуфабрикаты=%2",
		ПараметрыДерева.ТипРезультата,
		Строка(ПараметрыДерева.ДобавлятьПолуфабрикатыВРезультат));
	ЗаписьЖурналаРегистрации(
		"СтруктураСебестоимости.Диагностика",
		УровеньЖурналаРегистрации.Информация,
		,
		,
		ТекстСообщения);	
	
	АналитикаУчетаПродукции = ОписаниеПродукции.АналитикаУчетаПродукции;
	ПартияПродукции = ОписаниеПродукции.ПартияПродукции;
	АналитикаУчетаПартийПродукции = ОписаниеПродукции.АналитикаУчетаПартийПродукции;
	УровеньУзла = ОписаниеПродукции.Уровень + 1;
	
	ЭтоРазузлованиеДопРасходов = Ложь;
	
	Для Каждого ТекПартия Из СебестоимостьУзла Цикл
		
		// Проверка на циклическую зависимость
		МассивСтрок = Новый Массив;
		Если ТекПартия.ТребуетсяРазузлование И ТекПартия.КоличествоЗатрата <> 0 Тогда
			ПараметрыОтбора = Новый Структура("Партия, АналитикаУчетаПартий",
				ТекПартия.ПартияЗатрата,
				ТекПартия.АналитикаУчетаПартийЗатрата);
			МассивСтрок = ПройденныйПуть.НайтиСтроки(ПараметрыОтбора);
			
			// Логирование обнаруженного цикла
			Если МассивСтрок.Количество() > 0 Тогда
				ИнформацияОЦикле = Новый Структура;
				ИнформацияОЦикле.Вставить("Уровень", УровеньУзла);
				ИнформацияОЦикле.Вставить("ПартияЗатрата", ТекПартия.ПартияЗатрата);
				ИнформацияОЦикле.Вставить("АналитикаУчетаПартийЗатрата", ТекПартия.АналитикаУчетаПартийЗатрата);
				ИнформацияОЦикле.Вставить("Затрата", ТекПартия.Затрата);
				ИнформацияОЦикле.Вставить("ПартияПродукции", ПартияПродукции);
				ИнформацияОЦикле.Вставить("АналитикаУчетаПартийПродукции", АналитикаУчетаПартийПродукции);
				
				ПараметрыДерева.ОбнаруженныеЦиклы.Добавить(ИнформацияОЦикле);
				
				ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					"Обнаружен циклический переход на уровне %1: Затрата '%2' (Партия: %3, Аналитика партий: %4) -> уже обрабатывалась в пути от Партии: %5, Аналитики партий: %6",
					Строка(УровеньУзла),
					Строка(ТекПартия.Затрата),
					Строка(ТекПартия.ПартияЗатрата),
					Строка(ТекПартия.АналитикаУчетаПартийЗатрата),
					Строка(ПартияПродукции),
					Строка(АналитикаУчетаПартийПродукции));
				ЗаписьЖурналаРегистрации(
					"СтруктураСебестоимости.ОбнаруженЦикл",
					УровеньЖурналаРегистрации.Предупреждение,
					,
					,
					ТекстСообщения);
			КонецЕсли;
		КонецЕсли;
		
		// Добавляем строку в результат
		УсловиеДобавления = ПараметрыДерева.ТипРезультата = "ДеревоЗначений"
			ИЛИ ПараметрыДерева.ДобавлятьПолуфабрикатыВРезультат
			ИЛИ Не ТекПартия.ТребуетсяРазузлование;
		
		// ДИАГНОСТИКА: проверка, почему строка не добавляется
		Если НЕ УсловиеДобавления Тогда
			ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				"Строка НЕ добавлена: Затрата='%1', ТипРезультата='%2', ДобавлятьПолуфабрикаты=%3, ТребуетсяРазузлование=%4",
				Строка(ТекПартия.Затрата),
				ПараметрыДерева.ТипРезультата,
				Строка(ПараметрыДерева.ДобавлятьПолуфабрикатыВРезультат),
				Строка(ТекПартия.ТребуетсяРазузлование));
			ЗаписьЖурналаРегистрации(
				"СтруктураСебестоимости.Диагностика",
				УровеньЖурналаРегистрации.Предупреждение,
				,
				,
				ТекстСообщения);
		КонецЕсли;
		
		Если УсловиеДобавления Тогда			
			СтрокаПартия = Результат.Добавить();
			ЗаполнитьЗначенияСвойств(СтрокаПартия, ТекПартия);
			
			СтрокаПартия.Идентификатор = Новый УникальныйИдентификатор();
			Если ТекПартия.ТребуетсяРазузлование
				И Окр(ТекПартия.КоличествоЗатрата, 3) <> 0
				И (ТекПартия.СуммаЗатрата <> 0 ИЛИ ТекПартия.СуммаЗатратаЗабалансовая <> 0)
				И МассивСтрок.Количество() = 0 Тогда
				
				СтрокаПартия.ВидСтроки = Перечисления.ВидыСтрокДереваСебестоимости.ПартияПолуфабриката;
				СтрокаПартия.Числитель = ТекПартия.КоличествоЗатрата;
			Иначе
				СтрокаПартия.ВидСтроки = Перечисления.ВидыСтрокДереваСебестоимости.ПартияЗатраты;
				// КРИТИЧНО: НЕ перезаписываем ТребуетсяРазузлование!
				// Это поле уже правильно заполнено из запроса через ЗаполнитьЗначенияСвойств выше
				// и используется отчётом для фильтрации: ГДЕ ТребуетсяРазузлование ИЛИ ВидСтроки = Полуфабрикат
			КонецЕсли;
			
			// КРИТИЧНО: Заполняем поля партии продукции из ОписаниеПродукции (корневая продукция)!
			// ПартияПродукции - это партия КОРНЕВОЙ продукции, которая передаётся неизменной
			// через все уровни рекурсии. Это нужно для правильного соединения в отчёте:
			// ВТПродукция.ПартияПродукции = Затраты.ПартияПродукции
			// А поле ПартияВыходноеИзделие (партия непосредственного родителя-полуфабриката)
			// копируется через ЗаполнитьЗначенияСвойств выше!
			СтрокаПартия.ПартияПродукции = ПартияПродукции;
			СтрокаПартия.АналитикаУчетаПартийПродукции = АналитикаУчетаПартийПродукции;
			СтрокаПартия.АналитикаУчетаПродукции = АналитикаУчетаПродукции;
			
		// КРИТИЧНО: Заполняем аналитику выходного изделия из ОписаниеПродукции!
		// В СТАРОМ алгоритме (строки 585, 617): 
		//   НоваяСтрока.ПартияВыходноеИзделие = ОписаниеПродукции.ПартияПродукции;
		// ПартияВыходноеИзделие должна быть = партия КОРНЕВОЙ продукции, а не промежуточного полуфабриката!
		// Это нужно для правильного join в отчёте:
		//   ВТПродукция.ПартияПродукции = Затраты.ПартияПолуфабриката (= Результат.ПартияВыходноеИзделие)
		// ЗаполнитьЗначенияСвойств копирует из запроса партию промежуточного полуфабриката,
		// но нужна партия КОРНЕВОЙ продукции из ОписаниеПродукции!
			СтрокаПартия.ПартияВыходноеИзделие = ПартияПродукции;
			СтрокаПартия.АналитикаУчетаПартийВыходноеИзделие = АналитикаУчетаПартийПродукции;
			СтрокаПартия.АналитикаУчетаВыходноеИзделие = АналитикаУчетаПродукции;
			
			СтрокаПартия.Номенклатура = ТекПартия.Затрата;
			СтрокаПартия.Характеристика = ТекПартия.ХарактеристикаЗатрата;
			СтрокаПартия.Серия = ТекПартия.СерияЗатрата;
			СтрокаПартия.Назначение = ТекПартия.НазначениеЗатрата;
			СтрокаПартия.Партия = ТекПартия.ПартияЗатрата;
			СтрокаПартия.АналитикаУчетаПартий = ТекПартия.АналитикаУчетаПартийЗатрата;
			СтрокаПартия.ЕдиницаИзмерения = ТекПартия.ЕдиницаИзмеренияЗатрата;
			СтрокаПартия.Уровень = УровеньУзла;
			
			СтрокаПартия.Количество = ТекПартия.КоличествоЗатрата;
			СтрокаПартия.Сумма = Окр(ТекПартия.СуммаЗатрата, 2);
			СтрокаПартия.ДопРасходы = Окр(СтрокаПартия.ДопРасходы, 2);
			СтрокаПартия.НалоговыйУчет = Окр(СтрокаПартия.НалоговыйУчет, 2);
			СтрокаПартия.СуммаЗабалансовая = ТекПартия.СуммаЗатратаЗабалансовая;
			
			// Уменьшаем суммовые показатели в узле
			Если ПараметрыУзла.Сумма <> 0 ИЛИ ПараметрыУзла.СуммаЗабалансовая <> 0 Тогда
				ПараметрыУзла.Сумма = ПараметрыУзла.Сумма - СтрокаПартия.Сумма;
				ПараметрыУзла.Материальные = ПараметрыУзла.Материальные - СтрокаПартия.Материальные;
				ПараметрыУзла.ДопРасходы = ПараметрыУзла.ДопРасходы - СтрокаПартия.ДопРасходы;
				ПараметрыУзла.Трудозатраты = ПараметрыУзла.Трудозатраты - СтрокаПартия.Трудозатраты;
				ПараметрыУзла.ПостатейныеПеременные = ПараметрыУзла.ПостатейныеПеременные - СтрокаПартия.ПостатейныеПеременные;
				ПараметрыУзла.ПостатейныеПостоянные = ПараметрыУзла.ПостатейныеПостоянные - СтрокаПартия.ПостатейныеПостоянные;
				ПараметрыУзла.НалоговыйУчет = ПараметрыУзла.НалоговыйУчет - СтрокаПартия.НалоговыйУчет;
				ПараметрыУзла.ПостояннаяРазница = ПараметрыУзла.ПостояннаяРазница - СтрокаПартия.ПостояннаяРазница;
				ПараметрыУзла.ВременнаяРазница = ПараметрыУзла.ВременнаяРазница - СтрокаПартия.ВременнаяРазница;
				ПараметрыУзла.СуммаЗабалансовая = ПараметрыУзла.СуммаЗабалансовая - СтрокаПартия.СуммаЗабалансовая;
				
				ЭтоРазузлованиеДопРасходов = (ТекПартия.ТипЗатрат = "ДопРасходы");
			КонецЕсли;
		КонецЕсли;
		
		// Подготовка узла для следующего уровня
		Если (ТекПартия.ТребуетсяРазузлование
			И Окр(ТекПартия.КоличествоЗатрата, 3) <> 0
			И (ТекПартия.СуммаЗатрата <> 0 ИЛИ ТекПартия.СуммаЗатратаЗабалансовая <> 0)
			И МассивСтрок.Количество() = 0)
			ИЛИ (ТекПартия.ТребуетсяРазузлованиеДопРасходов
			И Окр(ТекПартия.КоличествоЗатрата, 3) <> 0
			И ТекПартия.ДопРасходы <> 0) Тогда
			
			ПараметрыУзлаПартии = СтруктураСебестоимости.ПараметрыУзлаДереваСебестоимости();
			
			// Добавляем партию в пройденный путь (НЕ для дополнительных расходов)
			Если НЕ ТекПартия.ТребуетсяРазузлованиеДопРасходов Тогда
				НовыйПуть = ПройденныйПуть.Добавить();
				НовыйПуть.Партия = ТекПартия.ПартияЗатрата;
				НовыйПуть.АналитикаУчетаПартий = ТекПартия.АналитикаУчетаПартийЗатрата;
			КонецЕсли;
			
			Отборы = ПараметрыУзлаПартии.Отборы;
			Отборы.ДанныеПоСебестоимости = ПараметрыУзла.Отборы.ДанныеПоСебестоимости;
			Отборы.Продукция.Добавить(ТекПартия.Затрата);
			Отборы.ХарактеристикиПродукции.Добавить(ТекПартия.ХарактеристикаЗатрата);
			Отборы.СерииПродукции.Добавить(ТекПартия.СерияЗатрата);
			Отборы.ПартииПродукции.Добавить(ТекПартия.ПартияЗатрата);
			Отборы.АналитикиУчетаПартийПродукции.Добавить(ТекПартия.АналитикаУчетаПартийЗатрата);
			Отборы.АналитикаУчетаЗатрата.Добавить(ТекПартия.АналитикаУчетаЗатрата);
			Отборы.Числитель = ТекПартия.КоличествоЗатрата;
			Отборы.КоличествоПродукции = Макс(-ТекПартия.КоличествоЗатрата, ТекПартия.КоличествоЗатрата);
			Отборы.РазворачиватьДопРасходы = ПараметрыУзла.Отборы.РазворачиватьДопРасходы;
			Отборы.ДатаИсходнойПартии = ПараметрыУзла.Отборы.ДатаИсходнойПартии;
			Отборы.ДатаОкончания = ПараметрыУзла.Отборы.ДатаОкончания;
			Отборы.ВключитьНДСВСтоимость = ТекПартия.ВключитьНДСВСтоимость;
			Отборы.ИсключитьНДСИзСтоимости = ТекПартия.ИсключитьНДСИзСтоимости;
			Отборы.АналитикаУчетаВыходноеИзделие = ТекПартия.АналитикаУчетаЗатрата;
			Отборы.СтатьяКалькуляции = ТекПартия.СтатьяКалькуляции;
			
		Если ПараметрыДерева.ТипРезультата = "ДеревоЗначений" Тогда
			ТаблицаРезультатаПартии = СтрокаПартия;
		Иначе
			ТаблицаРезультатаПартии = Результат;
		КонецЕсли;
		
		// КРИТИЧНО: Заполняем ПараметрыУзлаПартии из ТекПартия (а не СтрокаПартия),
		// т.к. СтрокаПартия может быть не создана, если ДобавлятьПолуфабрикатыВРезультат = Ложь
		// Также в старом алгоритме это делается только для обычных партий (НЕ для дополнительных расходов)
		Если НЕ ТекПартия.ТребуетсяРазузлованиеДопРасходов Тогда
			ПараметрыУзлаПартии.Сумма = ТекПартия.СуммаЗатрата;
			ПараметрыУзлаПартии.Материальные = ТекПартия.Материальные;
			ПараметрыУзлаПартии.ДопРасходы = ТекПартия.ДопРасходы;
			ПараметрыУзлаПартии.Трудозатраты = ТекПартия.Трудозатраты;
			ПараметрыУзлаПартии.ПостатейныеПеременные = ТекПартия.ПостатейныеПеременные;
			ПараметрыУзлаПартии.ПостатейныеПостоянные = ТекПартия.ПостатейныеПостоянные;
			ПараметрыУзлаПартии.НалоговыйУчет = ТекПартия.НалоговыйУчет;
			ПараметрыУзлаПартии.ПостояннаяРазница = ТекПартия.ПостояннаяРазница;
			ПараметрыУзлаПартии.ВременнаяРазница = ТекПартия.ВременнаяРазница;
			ПараметрыУзлаПартии.СуммаЗабалансовая = ТекПартия.СуммаЗатратаЗабалансовая;
		КонецЕсли;
			
		// КРИТИЧНО: Передаём данные КОРНЕВОЙ продукции, как в старом алгоритме!
		// В старом алгоритме ОписаниеПродукции передаётся НЕИЗМЕННЫМ через все уровни рекурсии.
		// Только поле Уровень обновляется для каждого нового уровня.
		// Это нужно для правильного соединения в отчёте:
		// ВТПродукция.ПартияПродукции = Затраты.ПартияПродукции
		НовоеОписаниеПродукции = Новый Структура("АналитикаУчетаПродукции, ПартияПродукции, АналитикаУчетаПартийПродукции");
		НовоеОписаниеПродукции.АналитикаУчетаПродукции = АналитикаУчетаПродукции;
		НовоеОписаниеПродукции.ПартияПродукции = ПартияПродукции;
		НовоеОписаниеПродукции.АналитикаУчетаПартийПродукции = АналитикаУчетаПартийПродукции;
		НовоеОписаниеПродукции.Вставить("Уровень", УровеньУзла);
		
		// Определяем СтрокаПартия: она существует только если УсловиеДобавления было Истина
		// В противном случае (полуфабрикат с ДобавлятьПолуфабрикатыВРезультат = Ложь)
		// передаем Неопределено
		СтрокаДляУзла = Неопределено;
		Если УсловиеДобавления Тогда
			СтрокаДляУзла = СтрокаПартия;
		КонецЕсли;
		
		НовыйУзел = Новый Структура;
		НовыйУзел.Вставить("ПараметрыУзла", ПараметрыУзлаПартии);
		НовыйУзел.Вставить("ТаблицаРезультата", ТаблицаРезультатаПартии);
		НовыйУзел.Вставить("ОписаниеПродукции", НовоеОписаниеПродукции);
		НовыйУзел.Вставить("СтрокаПартия", СтрокаДляУзла);
		
		УзлыСледующегоУровня.Добавить(НовыйУзел);
		КонецЕсли;
		
	КонецЦикла;
	
	// ДИАГНОСТИКА
	КоличествоПосле = Результат.Количество();
	ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		"ОбработатьРезультатыУзла: добавлено строк=%1 (было=%2, стало=%3), следующий уровень узлов=%4",
		Строка(КоличествоПосле - КоличествоДо),
		Строка(КоличествоДо),
		Строка(КоличествоПосле),
		Строка(УзлыСледующегоУровня.Количество()));
	ЗаписьЖурналаРегистрации(
		"СтруктураСебестоимости.Диагностика",
		УровеньЖурналаРегистрации.Информация,
		,
		,
		ТекстСообщения);
		
	// При наличии данных о разузловании добавим строку на суммы изменения стоимости
	Если СебестоимостьУзла.Количество() > 0 И НЕ ЭтоРазузлованиеДопРасходов Тогда
		УчестьИзменениеСтоимости(ПараметрыУзла, ОписаниеПродукции, Результат);
	КонецЕсли;
	
КонецПроцедуры   

// Пакетное получение себестоимости для нескольких узлов одним запросом (оптимизация N+1)
//
// Параметры:
//  МассивПараметровУзлов - Массив из Структура - Массив параметров узлов для обработки
//  ВыводитьДопРасходы - Булево - Выводить ли дополнительные расходы
//  ОбщиеПараметры - Структура - Общие параметры для всех узлов (ДанныеПоСебестоимости и т.д.)
//
// Возвращаемое значение:
//  Соответствие - Ключ: идентификатор узла (Партия+АналитикаПартий), Значение: ТаблицаЗначений с данными себестоимости
//
Функция СебестоимостьУзловПакетом(МассивПараметровУзлов, ВыводитьДопРасходы, ОбщиеПараметры)
	
	Если МассивПараметровУзлов.Количество() = 0 Тогда
		Возврат Новый Соответствие;
	КонецЕсли;
	
	// Собираем все партии и аналитики для пакетного запроса
	// + создаём индекс для быстрого распределения результатов
	ВсеПартииПродукции = Новый Массив;
	ВсеАналитикиУчетаПартийПродукции = Новый Массив;
	ВсеПродукция = Новый Массив;
	ВсеХарактеристики = Новый Массив;
	ВсеСерии = Новый Массив;
	ВсеНазначения = Новый Массив;
	
	// Индекс: Партия -> КлючУзла (для распределения результатов)
	ИндексПартийПоУзлам = Новый Соответствие;
	
	Для Каждого ПараметрыУзла Из МассивПараметровУзлов Цикл
		Отборы = ПараметрыУзла.Отборы;
		КлючУзла = СоздатьКлючУзла(ПараметрыУзла);
		
		Для Каждого Партия Из Отборы.ПартииПродукции Цикл
			Если ВсеПартииПродукции.Найти(Партия) = Неопределено Тогда
				ВсеПартииПродукции.Добавить(Партия);
			КонецЕсли;
			// Связываем партию с ключом узла для распределения результатов
			ИндексПартийПоУзлам.Вставить(Партия, КлючУзла);
		КонецЦикла;
		
		Для Каждого Аналитика Из Отборы.АналитикиУчетаПартийПродукции Цикл
			Если ВсеАналитикиУчетаПартийПродукции.Найти(Аналитика) = Неопределено Тогда
				ВсеАналитикиУчетаПартийПродукции.Добавить(Аналитика);
			КонецЕсли;
		КонецЦикла;
		
		Для Каждого Продукция Из Отборы.Продукция Цикл
			Если ВсеПродукция.Найти(Продукция) = Неопределено Тогда
				ВсеПродукция.Добавить(Продукция);
			КонецЕсли;
		КонецЦикла;
		
		Для Каждого Характеристика Из Отборы.ХарактеристикиПродукции Цикл
			Если ВсеХарактеристики.Найти(Характеристика) = Неопределено Тогда
				ВсеХарактеристики.Добавить(Характеристика);
			КонецЕсли;
		КонецЦикла;
		
		Для Каждого Серия Из Отборы.СерииПродукции Цикл
			Если ВсеСерии.Найти(Серия) = Неопределено Тогда
				ВсеСерии.Добавить(Серия);
			КонецЕсли;
		КонецЦикла;
		
		Для Каждого Назначение Из Отборы.НазначенияПродукции Цикл
			Если ВсеНазначения.Найти(Назначение) = Неопределено Тогда
				ВсеНазначения.Добавить(Назначение);
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	
	// Создаем объединенные параметры для пакетного запроса
	ПараметрыУзлаОбъединенные = СтруктураСебестоимости.ПараметрыУзлаДереваСебестоимости();
	ОтборыОбъединенные = ПараметрыУзлаОбъединенные.Отборы;
	
	// Копируем общие параметры из первого узла (они должны быть одинаковыми)
	ПервыйУзел = МассивПараметровУзлов[0];
	ОтборыОбъединенные.ДанныеПоСебестоимости = ПервыйУзел.Отборы.ДанныеПоСебестоимости;
	ОтборыОбъединенные.РазворачиватьДопРасходы = ПервыйУзел.Отборы.РазворачиватьДопРасходы;
	ОтборыОбъединенные.ДатаОкончания = ПервыйУзел.Отборы.ДатаОкончания;
	ОтборыОбъединенные.ДатаИсходнойПартии = ПервыйУзел.Отборы.ДатаИсходнойПартии;
	
	// Устанавливаем объединенные массивы
	ОтборыОбъединенные.ПартииПродукции = ВсеПартииПродукции;
	ОтборыОбъединенные.АналитикиУчетаПартийПродукции = ВсеАналитикиУчетаПартийПродукции;
	ОтборыОбъединенные.Продукция = ВсеПродукция;
	ОтборыОбъединенные.ХарактеристикиПродукции = ВсеХарактеристики;
	ОтборыОбъединенные.СерииПродукции = ВсеСерии;
	ОтборыОбъединенные.НазначенияПродукции = ВсеНазначения;
	
	// Выполняем ОДИН запрос для ВСЕХ узлов уровня
	Запрос = ЗапросВыпущеннаяПродукция(ПараметрыУзлаОбъединенные, Истина);
	Запрос.Текст = Запрос.Текст + ТекстЗапросаЗатратыНаПродукцию(ВыводитьДопРасходы);
	
	ВсеДанные = Запрос.Выполнить().Выгрузить();
	
	// Распределяем результаты по узлам на основе ПартияПродукции
	// Каждая строка результата относится к конкретной партии продукции
	РезультатПоУзлам = Новый Соответствие;
	
	// Инициализируем пустые таблицы для каждого узла
	Для Каждого ПараметрыУзла Из МассивПараметровУзлов Цикл
		КлючУзла = СоздатьКлючУзла(ПараметрыУзла);
		// Создаём пустую таблицу с такой же структурой
		ТаблицаУзла = ВсеДанные.СкопироватьКолонки();
		РезультатПоУзлам.Вставить(КлючУзла, ТаблицаУзла);
	КонецЦикла;
	
	// Распределяем строки по узлам на основе партии продукции
	Для Каждого СтрокаДанных Из ВсеДанные Цикл
		// Находим ключ узла по партии продукции
		КлючУзла = ИндексПартийПоУзлам.Получить(СтрокаДанных.ПартияПродукции);
		
		Если КлючУзла <> Неопределено Тогда
			ТаблицаУзла = РезультатПоУзлам.Получить(КлючУзла);
			Если ТаблицаУзла <> Неопределено Тогда
				НоваяСтрока = ТаблицаУзла.Добавить();
				ЗаполнитьЗначенияСвойств(НоваяСтрока, СтрокаДанных);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Возврат РезультатПоУзлам;
	
КонецФункции

// Создает уникальный ключ для узла на основе его параметров
Функция СоздатьКлючУзла(ПараметрыУзла)
	
	Отборы = ПараметрыУзла.Отборы;
	
	КлючПартии = "";
	Для Каждого Партия Из Отборы.ПартииПродукции Цикл
		КлючПартии = КлючПартии + Строка(Партия.УникальныйИдентификатор()) + ";";
	КонецЦикла;
	
	КлючАналитики = "";
	Для Каждого Аналитика Из Отборы.АналитикиУчетаПартийПродукции Цикл
		КлючАналитики = КлючАналитики + Строка(Аналитика.УникальныйИдентификатор()) + ";";
	КонецЦикла;
	
	Возврат КлючПартии + "|" + КлючАналитики;
	
КонецФункции


//	#Удаление
//	#КонецУдаления
//	#Вставка
// 	#КонецВставки

